{"ast":null,"code":"'use strict';\n\nfunction _classPrivateFieldInitSpec(obj, privateMap, value) {\n  _checkPrivateRedeclaration(obj, privateMap);\n  privateMap.set(obj, value);\n}\nfunction _checkPrivateRedeclaration(obj, privateCollection) {\n  if (privateCollection.has(obj)) {\n    throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n  }\n}\nfunction _classPrivateFieldGet(s, a) {\n  return s.get(_assertClassBrand(s, a));\n}\nfunction _classPrivateFieldSet(s, a, r) {\n  return s.set(_assertClassBrand(s, a), r), r;\n}\nfunction _assertClassBrand(e, t, n) {\n  if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n;\n  throw new TypeError(\"Private element is not present on this object\");\n}\nimport { has } from './utils';\nimport { WorkletEventHandler } from '../WorkletEventHandler';\nimport findNodeHandle from \"react-native-web/dist/exports/findNodeHandle\";\nvar _managedComponent = new WeakMap();\nvar _componentOptions = new WeakMap();\nvar _eventViewTag = new WeakMap();\nexport class NativeEventsManager {\n  constructor(component, options) {\n    _classPrivateFieldInitSpec(this, _managedComponent, void 0);\n    _classPrivateFieldInitSpec(this, _componentOptions, void 0);\n    _classPrivateFieldInitSpec(this, _eventViewTag, -1);\n    _classPrivateFieldSet(_managedComponent, this, component);\n    _classPrivateFieldSet(_componentOptions, this, options);\n    _classPrivateFieldSet(_eventViewTag, this, this.getEventViewTag());\n  }\n  attachEvents() {\n    executeForEachEventHandler(_classPrivateFieldGet(_managedComponent, this).props, (key, handler) => {\n      handler.registerForEvents(_classPrivateFieldGet(_eventViewTag, this), key);\n    });\n  }\n  detachEvents() {\n    executeForEachEventHandler(_classPrivateFieldGet(_managedComponent, this).props, (_key, handler) => {\n      handler.unregisterFromEvents(_classPrivateFieldGet(_eventViewTag, this));\n    });\n  }\n  updateEvents(prevProps) {\n    const computedEventTag = this.getEventViewTag();\n    if (_classPrivateFieldGet(_eventViewTag, this) !== computedEventTag) {\n      executeForEachEventHandler(prevProps, (_key, handler) => {\n        handler.unregisterFromEvents(_classPrivateFieldGet(_eventViewTag, this));\n      });\n      _classPrivateFieldSet(_eventViewTag, this, computedEventTag);\n      this.attachEvents();\n      return;\n    }\n    executeForEachEventHandler(prevProps, (key, prevHandler) => {\n      const newProp = _classPrivateFieldGet(_managedComponent, this).props[key];\n      if (!newProp) {\n        prevHandler.unregisterFromEvents(_classPrivateFieldGet(_eventViewTag, this));\n      } else if (isWorkletEventHandler(newProp) && newProp.workletEventHandler !== prevHandler) {\n        prevHandler.unregisterFromEvents(_classPrivateFieldGet(_eventViewTag, this));\n        newProp.workletEventHandler.registerForEvents(_classPrivateFieldGet(_eventViewTag, this));\n      }\n    });\n    executeForEachEventHandler(_classPrivateFieldGet(_managedComponent, this).props, (key, handler) => {\n      if (!prevProps[key]) {\n        handler.registerForEvents(_classPrivateFieldGet(_eventViewTag, this));\n      }\n    });\n  }\n  getEventViewTag() {\n    const componentAnimatedRef = _classPrivateFieldGet(_managedComponent, this)._component;\n    let newTag;\n    if (componentAnimatedRef.getScrollableNode) {\n      const scrollableNode = componentAnimatedRef.getScrollableNode();\n      newTag = findNodeHandle(scrollableNode) ?? -1;\n    } else {\n      var _classPrivateFieldGet2;\n      newTag = findNodeHandle((_classPrivateFieldGet2 = _classPrivateFieldGet(_componentOptions, this)) !== null && _classPrivateFieldGet2 !== void 0 && _classPrivateFieldGet2.setNativeProps ? _classPrivateFieldGet(_managedComponent, this) : componentAnimatedRef) ?? -1;\n    }\n    return newTag;\n  }\n}\nfunction isWorkletEventHandler(prop) {\n  return has('workletEventHandler', prop) && prop.workletEventHandler instanceof WorkletEventHandler;\n}\nfunction executeForEachEventHandler(props, callback) {\n  for (const key in props) {\n    const prop = props[key];\n    if (isWorkletEventHandler(prop)) {\n      callback(key, prop.workletEventHandler);\n    }\n  }\n}","map":{"version":3,"names":["_classPrivateFieldInitSpec","obj","privateMap","value","_checkPrivateRedeclaration","set","privateCollection","has","TypeError","_classPrivateFieldGet","s","a","get","_assertClassBrand","_classPrivateFieldSet","r","e","t","n","arguments","length","WorkletEventHandler","findNodeHandle","_managedComponent","WeakMap","_componentOptions","_eventViewTag","NativeEventsManager","constructor","component","options","getEventViewTag","attachEvents","executeForEachEventHandler","props","key","handler","registerForEvents","detachEvents","_key","unregisterFromEvents","updateEvents","prevProps","computedEventTag","prevHandler","newProp","isWorkletEventHandler","workletEventHandler","componentAnimatedRef","_component","newTag","getScrollableNode","scrollableNode","_classPrivateFieldGet2","setNativeProps","prop","callback"],"sources":["C:\\Users\\user\\OneDrive\\Documents\\rn\\l\\node_modules\\react-native-reanimated\\lib\\module\\createAnimatedComponent\\NativeEventsManager.ts"],"sourcesContent":["'use strict';\nimport type {\n  INativeEventsManager,\n  IAnimatedComponentInternal,\n  AnimatedComponentProps,\n  InitialComponentProps,\n  AnimatedComponentRef,\n} from './commonTypes';\nimport { has } from './utils';\nimport { WorkletEventHandler } from '../WorkletEventHandler';\nimport { findNodeHandle } from 'react-native';\n\nexport class NativeEventsManager implements INativeEventsManager {\n  readonly #managedComponent: ManagedAnimatedComponent;\n  readonly #componentOptions?: ComponentOptions;\n  #eventViewTag = -1;\n\n  constructor(component: ManagedAnimatedComponent, options?: ComponentOptions) {\n    this.#managedComponent = component;\n    this.#componentOptions = options;\n    this.#eventViewTag = this.getEventViewTag();\n  }\n\n  public attachEvents() {\n    executeForEachEventHandler(this.#managedComponent.props, (key, handler) => {\n      handler.registerForEvents(this.#eventViewTag, key);\n    });\n  }\n\n  public detachEvents() {\n    executeForEachEventHandler(\n      this.#managedComponent.props,\n      (_key, handler) => {\n        handler.unregisterFromEvents(this.#eventViewTag);\n      }\n    );\n  }\n\n  public updateEvents(\n    prevProps: AnimatedComponentProps<InitialComponentProps>\n  ) {\n    const computedEventTag = this.getEventViewTag();\n    // If the event view tag changes, we need to completely re-mount all events\n    if (this.#eventViewTag !== computedEventTag) {\n      // Remove all bindings from previous props that ran on the old viewTag\n      executeForEachEventHandler(prevProps, (_key, handler) => {\n        handler.unregisterFromEvents(this.#eventViewTag);\n      });\n      // We don't need to unregister from current (new) props, because their events weren't registered yet\n      // Replace the view tag\n      this.#eventViewTag = computedEventTag;\n      // Attach the events with a new viewTag\n      this.attachEvents();\n      return;\n    }\n\n    executeForEachEventHandler(prevProps, (key, prevHandler) => {\n      const newProp = this.#managedComponent.props[key];\n      if (!newProp) {\n        // Prop got deleted\n        prevHandler.unregisterFromEvents(this.#eventViewTag);\n      } else if (\n        isWorkletEventHandler(newProp) &&\n        newProp.workletEventHandler !== prevHandler\n      ) {\n        // Prop got changed\n        prevHandler.unregisterFromEvents(this.#eventViewTag);\n        newProp.workletEventHandler.registerForEvents(this.#eventViewTag);\n      }\n    });\n\n    executeForEachEventHandler(this.#managedComponent.props, (key, handler) => {\n      if (!prevProps[key]) {\n        // Prop got added\n        handler.registerForEvents(this.#eventViewTag);\n      }\n    });\n  }\n\n  private getEventViewTag() {\n    // Get the tag for registering events - since the event emitting view can be nested inside the main component\n    const componentAnimatedRef = this.#managedComponent\n      ._component as AnimatedComponentRef;\n    let newTag: number;\n    if (componentAnimatedRef.getScrollableNode) {\n      const scrollableNode = componentAnimatedRef.getScrollableNode();\n      newTag = findNodeHandle(scrollableNode) ?? -1;\n    } else {\n      newTag =\n        findNodeHandle(\n          this.#componentOptions?.setNativeProps\n            ? this.#managedComponent\n            : componentAnimatedRef\n        ) ?? -1;\n    }\n    return newTag;\n  }\n}\n\nfunction isWorkletEventHandler(\n  prop: unknown\n): prop is WorkletEventHandlerHolder {\n  return (\n    has('workletEventHandler', prop) &&\n    prop.workletEventHandler instanceof WorkletEventHandler\n  );\n}\n\nfunction executeForEachEventHandler(\n  props: AnimatedComponentProps<InitialComponentProps>,\n  callback: (\n    key: string,\n    handler: InstanceType<typeof WorkletEventHandler>\n  ) => void\n) {\n  for (const key in props) {\n    const prop = props[key];\n    if (isWorkletEventHandler(prop)) {\n      callback(key, prop.workletEventHandler);\n    }\n  }\n}\n\ntype ManagedAnimatedComponent = React.Component<\n  AnimatedComponentProps<InitialComponentProps>\n> &\n  IAnimatedComponentInternal;\n\ntype ComponentOptions = {\n  setNativeProps: (\n    ref: AnimatedComponentRef,\n    props: InitialComponentProps\n  ) => void;\n};\n\ntype WorkletEventHandlerHolder = {\n  workletEventHandler: InstanceType<typeof WorkletEventHandler>;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}