{"ast":null,"code":"import _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/objectWithoutPropertiesLoose\";\nconst _excluded = [\"type\"],\n  _excluded2 = [\"style\"],\n  _excluded3 = [\"parse\", \"childrenProps\"];\nvar _jsxFileName = \"C:\\\\Users\\\\user\\\\OneDrive\\\\Documents\\\\rn\\\\l\\\\node_modules\\\\react-native-parsed-text\\\\src\\\\ParsedText.js\";\nimport React from 'react';\nimport Text from \"react-native-web/dist/exports/Text\";\nimport PropTypes from 'prop-types';\nimport TextExtraction from './lib/TextExtraction';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const PATTERNS = {\n  url: /(https?:\\/\\/|www\\.)[-a-zA-Z0-9@:%._\\+~#=]{1,256}\\.(xn--)?[a-z0-9-]{2,20}\\b([-a-zA-Z0-9@:%_\\+\\[\\],.~#?&\\/=]*[-a-zA-Z0-9@:%_\\+\\]~#?&\\/=])*/i,\n  phone: /[\\+]?[(]?[0-9]{3}[)]?[-\\s\\.]?[0-9]{3}[-\\s\\.]?[0-9]{4,7}/,\n  email: /\\S+@\\S+\\.\\S+/\n};\nconst defaultParseShape = PropTypes.shape(Object.assign({}, Text.propTypes, {\n  type: PropTypes.oneOf(Object.keys(PATTERNS)).isRequired,\n  nonExhaustiveMaxMatchCount: PropTypes.number\n}));\nconst customParseShape = PropTypes.shape(Object.assign({}, Text.propTypes, {\n  pattern: PropTypes.oneOfType([PropTypes.string, PropTypes.instanceOf(RegExp)]).isRequired,\n  nonExhaustiveMaxMatchCount: PropTypes.number\n}));\nclass ParsedText extends React.Component {\n  static displayName = 'ParsedText';\n  static propTypes = Object.assign({}, Text.propTypes, {\n    parse: PropTypes.arrayOf(PropTypes.oneOfType([defaultParseShape, customParseShape])),\n    childrenProps: PropTypes.shape(Text.propTypes)\n  });\n  static defaultProps = {\n    parse: null,\n    childrenProps: {}\n  };\n  setNativeProps(nativeProps) {\n    this._root.setNativeProps(nativeProps);\n  }\n  getPatterns() {\n    return this.props.parse.map(option => {\n      const {\n          type\n        } = option,\n        patternOption = _objectWithoutPropertiesLoose(option, _excluded);\n      if (type) {\n        if (!PATTERNS[type]) {\n          throw new Error(`${option.type} is not a supported type`);\n        }\n        patternOption.pattern = PATTERNS[type];\n      }\n      return patternOption;\n    });\n  }\n  getParsedText() {\n    if (!this.props.parse) {\n      return this.props.children;\n    }\n    if (typeof this.props.children !== 'string') {\n      return this.props.children;\n    }\n    const textExtraction = new TextExtraction(this.props.children, this.getPatterns());\n    return textExtraction.parse().map((props, index) => {\n      const {\n        style: parentStyle\n      } = this.props;\n      const {\n          style\n        } = props,\n        remainder = _objectWithoutPropertiesLoose(props, _excluded2);\n      return _jsxDEV(Text, Object.assign({\n        style: [parentStyle, style]\n      }, this.props.childrenProps, remainder), `parsedText-${index}`, false, {\n        fileName: _jsxFileName,\n        lineNumber: 114,\n        columnNumber: 9\n      }, this);\n    });\n  }\n  render() {\n    const _this$props = Object.assign({}, this.props),\n      remainder = _objectWithoutPropertiesLoose(_this$props, _excluded3);\n    return _jsxDEV(Text, Object.assign({\n      ref: ref => this._root = ref\n    }, remainder, {\n      children: this.getParsedText()\n    }), void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 129,\n      columnNumber: 7\n    }, this);\n  }\n}\nexport default ParsedText;","map":{"version":3,"names":["React","Text","PropTypes","TextExtraction","jsxDEV","_jsxDEV","PATTERNS","url","phone","email","defaultParseShape","shape","Object","assign","propTypes","type","oneOf","keys","isRequired","nonExhaustiveMaxMatchCount","number","customParseShape","pattern","oneOfType","string","instanceOf","RegExp","ParsedText","Component","displayName","parse","arrayOf","childrenProps","defaultProps","setNativeProps","nativeProps","_root","getPatterns","props","map","option","patternOption","_objectWithoutPropertiesLoose","_excluded","Error","getParsedText","children","textExtraction","index","style","parentStyle","remainder","_excluded2","fileName","_jsxFileName","lineNumber","columnNumber","render","_this$props","_excluded3","ref"],"sources":["C:/Users/user/OneDrive/Documents/rn/l/node_modules/react-native-parsed-text/src/ParsedText.js"],"sourcesContent":["import React from 'react';\nimport { Text } from 'react-native';\nimport PropTypes from 'prop-types';\n\nimport TextExtraction from './lib/TextExtraction';\n\n/**\n * This is a list of the known patterns that are provided by this library\n * @typedef {('url'|'phone'|'email')} KnownParsePattern\n */\n/**\n * @type {Object.<string, RegExp>}\n * // The keys really should be KnownParsePattern -- but this is unsupported in jsdoc, sadly\n */\nexport const PATTERNS = {\n  /**\n   * Segments/Features:\n   *  - http/https support https?\n   *  - auto-detecting loose domains if preceded by `www.`\n   *  - Localized & Long top-level domains \\.(xn--)?[a-z0-9-]{2,20}\\b\n   *  - Allowed query parameters & values, it's two blocks of matchers\n   *    ([-a-zA-Z0-9@:%_\\+,.~#?&\\/=]*[-a-zA-Z0-9@:%_\\+~#?&\\/=])*\n   *    - First block is [-a-zA-Z0-9@:%_\\+\\[\\],.~#?&\\/=]* -- this matches parameter names & values (including commas, dots, opening & closing brackets)\n   *    - The first block must be followed by a closing block [-a-zA-Z0-9@:%_\\+\\]~#?&\\/=] -- this doesn't match commas, dots, and opening brackets\n   */\n  url: /(https?:\\/\\/|www\\.)[-a-zA-Z0-9@:%._\\+~#=]{1,256}\\.(xn--)?[a-z0-9-]{2,20}\\b([-a-zA-Z0-9@:%_\\+\\[\\],.~#?&\\/=]*[-a-zA-Z0-9@:%_\\+\\]~#?&\\/=])*/i,\n  phone: /[\\+]?[(]?[0-9]{3}[)]?[-\\s\\.]?[0-9]{3}[-\\s\\.]?[0-9]{4,7}/,\n  email: /\\S+@\\S+\\.\\S+/,\n};\n\n/**\n * This is for built-in-patterns already supported by this library\n * Note: any additional keys/props are permitted, and will be passed along as props to the <Text> component!\n * @typedef {Object} DefaultParseShape\n * @property {KnownParsePattern} [type] key of the known pattern you'd like to configure\n * @property {number} [nonExhaustiveModeMaxMatchCount] Enables \"non-exhaustive mode\", where you can limit how many matches are found. -- Must be a positive integer or Infinity matches are permitted\n * @property {Function} [renderText] arbitrary function to rewrite the matched string into something else\n * @property {Function} [onPress]\n * @property {Function} [onLongPress]\n */\nconst defaultParseShape = PropTypes.shape({\n  ...Text.propTypes,\n  type: PropTypes.oneOf(Object.keys(PATTERNS)).isRequired,\n  nonExhaustiveMaxMatchCount: PropTypes.number,\n});\n\nconst customParseShape = PropTypes.shape({\n  ...Text.propTypes,\n  pattern: PropTypes.oneOfType([PropTypes.string, PropTypes.instanceOf(RegExp)])\n    .isRequired,\n  nonExhaustiveMaxMatchCount: PropTypes.number,\n});\n\n/**\n * The props added by this component\n * @typedef {DefaultParseShape|import('./lib/TextExtraction').CustomParseShape} ParsedTextAddedProps\n * @property {ParseShape[]} parse\n * @property {import('react-native').TextProps} childrenProps -- the props set on each child Text component\n */\n/** @typedef {ParsedTextAddedProps & import('react-native').TextProps} ParsedTextProps */\n\n/** @type {import('react').ComponentClass<ParsedTextProps>} */\nclass ParsedText extends React.Component {\n  static displayName = 'ParsedText';\n\n  static propTypes = {\n    ...Text.propTypes,\n    parse: PropTypes.arrayOf(\n      PropTypes.oneOfType([defaultParseShape, customParseShape]),\n    ),\n    childrenProps: PropTypes.shape(Text.propTypes),\n  };\n\n  static defaultProps = {\n    parse: null,\n    childrenProps: {},\n  };\n\n  setNativeProps(nativeProps) {\n    this._root.setNativeProps(nativeProps);\n  }\n  /** @returns {import('./lib/TextExtraction').CustomParseShape[]} */\n  getPatterns() {\n    return this.props.parse.map((option) => {\n      const { type, ...patternOption } = option;\n      if (type) {\n        if (!PATTERNS[type]) {\n          throw new Error(`${option.type} is not a supported type`);\n        }\n        patternOption.pattern = PATTERNS[type];\n      }\n\n      return patternOption;\n    });\n  }\n\n  getParsedText() {\n    if (!this.props.parse) {\n      return this.props.children;\n    }\n    if (typeof this.props.children !== 'string') {\n      return this.props.children;\n    }\n\n    const textExtraction = new TextExtraction(\n      this.props.children,\n      this.getPatterns(),\n    );\n\n    return textExtraction.parse().map((props, index) => {\n      const { style: parentStyle } = this.props;\n      const { style, ...remainder } = props;\n      return (\n        <Text\n          key={`parsedText-${index}`}\n          style={[parentStyle, style]}\n          {...this.props.childrenProps}\n          {...remainder}\n        />\n      );\n    });\n  }\n\n  render() {\n    // Discard custom props before passing remainder to Text\n    const { parse, childrenProps, ...remainder } = { ...this.props };\n\n    return (\n      <Text ref={(ref) => (this._root = ref)} {...remainder}>\n        {this.getParsedText()}\n      </Text>\n    );\n  }\n}\n\nexport default ParsedText;\n"],"mappings":";;;;;AAAA,OAAOA,KAAK,MAAM,OAAO;AAAC,OAAAC,IAAA;AAE1B,OAAOC,SAAS,MAAM,YAAY;AAElC,OAAOC,cAAc,MAAM,sBAAsB;AAAC,SAAAC,MAAA,IAAAC,OAAA;AAUlD,OAAO,MAAMC,QAAQ,GAAG;EAWtBC,GAAG,EAAE,2IAA2I;EAChJC,KAAK,EAAE,yDAAyD;EAChEC,KAAK,EAAE;AACT,CAAC;AAYD,MAAMC,iBAAiB,GAAGR,SAAS,CAACS,KAAK,CAAAC,MAAA,CAAAC,MAAA,KACpCZ,IAAI,CAACa,SAAS;EACjBC,IAAI,EAAEb,SAAS,CAACc,KAAK,CAACJ,MAAM,CAACK,IAAI,CAACX,QAAQ,CAAC,CAAC,CAACY,UAAU;EACvDC,0BAA0B,EAAEjB,SAAS,CAACkB;AAAM,EAC7C,CAAC;AAEF,MAAMC,gBAAgB,GAAGnB,SAAS,CAACS,KAAK,CAAAC,MAAA,CAAAC,MAAA,KACnCZ,IAAI,CAACa,SAAS;EACjBQ,OAAO,EAAEpB,SAAS,CAACqB,SAAS,CAAC,CAACrB,SAAS,CAACsB,MAAM,EAAEtB,SAAS,CAACuB,UAAU,CAACC,MAAM,CAAC,CAAC,CAAC,CAC3ER,UAAU;EACbC,0BAA0B,EAAEjB,SAAS,CAACkB;AAAM,EAC7C,CAAC;AAWF,MAAMO,UAAU,SAAS3B,KAAK,CAAC4B,SAAS,CAAC;EACvC,OAAOC,WAAW,GAAG,YAAY;EAEjC,OAAOf,SAAS,GAAAF,MAAA,CAAAC,MAAA,KACXZ,IAAI,CAACa,SAAS;IACjBgB,KAAK,EAAE5B,SAAS,CAAC6B,OAAO,CACtB7B,SAAS,CAACqB,SAAS,CAAC,CAACb,iBAAiB,EAAEW,gBAAgB,CAAC,CAC3D,CAAC;IACDW,aAAa,EAAE9B,SAAS,CAACS,KAAK,CAACV,IAAI,CAACa,SAAS;EAAC;EAGhD,OAAOmB,YAAY,GAAG;IACpBH,KAAK,EAAE,IAAI;IACXE,aAAa,EAAE,CAAC;EAClB,CAAC;EAEDE,cAAcA,CAACC,WAAW,EAAE;IAC1B,IAAI,CAACC,KAAK,CAACF,cAAc,CAACC,WAAW,CAAC;EACxC;EAEAE,WAAWA,CAAA,EAAG;IACZ,OAAO,IAAI,CAACC,KAAK,CAACR,KAAK,CAACS,GAAG,CAAEC,MAAM,IAAK;MACtC,MAAM;UAAEzB;QAAuB,CAAC,GAAGyB,MAAM;QAAxBC,aAAa,GAAAC,6BAAA,CAAKF,MAAM,EAAAG,SAAA;MACzC,IAAI5B,IAAI,EAAE;QACR,IAAI,CAACT,QAAQ,CAACS,IAAI,CAAC,EAAE;UACnB,MAAM,IAAI6B,KAAK,CAAC,GAAGJ,MAAM,CAACzB,IAAI,0BAA0B,CAAC;QAC3D;QACA0B,aAAa,CAACnB,OAAO,GAAGhB,QAAQ,CAACS,IAAI,CAAC;MACxC;MAEA,OAAO0B,aAAa;IACtB,CAAC,CAAC;EACJ;EAEAI,aAAaA,CAAA,EAAG;IACd,IAAI,CAAC,IAAI,CAACP,KAAK,CAACR,KAAK,EAAE;MACrB,OAAO,IAAI,CAACQ,KAAK,CAACQ,QAAQ;IAC5B;IACA,IAAI,OAAO,IAAI,CAACR,KAAK,CAACQ,QAAQ,KAAK,QAAQ,EAAE;MAC3C,OAAO,IAAI,CAACR,KAAK,CAACQ,QAAQ;IAC5B;IAEA,MAAMC,cAAc,GAAG,IAAI5C,cAAc,CACvC,IAAI,CAACmC,KAAK,CAACQ,QAAQ,EACnB,IAAI,CAACT,WAAW,CAAC,CACnB,CAAC;IAED,OAAOU,cAAc,CAACjB,KAAK,CAAC,CAAC,CAACS,GAAG,CAAC,CAACD,KAAK,EAAEU,KAAK,KAAK;MAClD,MAAM;QAAEC,KAAK,EAAEC;MAAY,CAAC,GAAG,IAAI,CAACZ,KAAK;MACzC,MAAM;UAAEW;QAAoB,CAAC,GAAGX,KAAK;QAAnBa,SAAS,GAAAT,6BAAA,CAAKJ,KAAK,EAAAc,UAAA;MACrC,OACE/C,OAAA,CAACJ,IAAI,EAAAW,MAAA,CAAAC,MAAA;QAEHoC,KAAK,EAAE,CAACC,WAAW,EAAED,KAAK;MAAE,GACxB,IAAI,CAACX,KAAK,CAACN,aAAa,EACxBmB,SAAS,GAHR,cAAcH,KAAK,EAAE;QAAAK,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OAI3B,CAAC;IAEN,CAAC,CAAC;EACJ;EAEAC,MAAMA,CAAA,EAAG;IAEP,MAAAC,WAAA,GAAA9C,MAAA,CAAAC,MAAA,KAAoD,IAAI,CAACyB,KAAK;MAA7Ba,SAAS,GAAAT,6BAAA,CAAAgB,WAAA,EAAAC,UAAA;IAE1C,OACEtD,OAAA,CAACJ,IAAI,EAAAW,MAAA,CAAAC,MAAA;MAAC+C,GAAG,EAAGA,GAAG,IAAM,IAAI,CAACxB,KAAK,GAAGwB;IAAK,GAAKT,SAAS;MAAAL,QAAA,EAClD,IAAI,CAACD,aAAa,CAAC;IAAC;MAAAQ,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OACjB,CAAC;EAEX;AACF;AAEA,eAAe7B,UAAU","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}