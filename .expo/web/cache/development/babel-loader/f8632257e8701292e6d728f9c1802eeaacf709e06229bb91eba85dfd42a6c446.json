{"ast":null,"code":"'use strict';\n\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/objectWithoutPropertiesLoose\";\nconst _excluded = [\"transform\"];\nimport { AnimationsData, TransitionType } from './config';\nimport { convertAnimationObjectToKeyframes } from './animationParser';\nimport { LinearTransition } from './transition/Linear.web';\nimport { SequencedTransition } from './transition/Sequenced.web';\nimport { FadingTransition } from './transition/Fading.web';\nimport { JumpingTransition } from './transition/Jumping.web';\nimport { insertWebAnimation } from './domUtils';\nimport { CurvedTransition } from './transition/Curved.web';\nimport { EntryExitTransition } from './transition/EntryExit.web';\nfunction addPxToTransform(transform) {\n  const newTransform = transform.map(transformProp => {\n    const newTransformProp = {};\n    for (const [key, value] of Object.entries(transformProp)) {\n      if ((key.includes('translate') || key.includes('perspective')) && typeof value === 'number') {\n        newTransformProp[key] = `${value}px`;\n      } else {\n        newTransformProp[key] = value;\n      }\n    }\n    return newTransformProp;\n  });\n  return newTransform;\n}\nexport function createCustomKeyFrameAnimation(keyframeDefinitions) {\n  for (const value of Object.values(keyframeDefinitions)) {\n    if (value.transform) {\n      value.transform = addPxToTransform(value.transform);\n    }\n  }\n  const animationData = {\n    name: '',\n    style: keyframeDefinitions,\n    duration: -1\n  };\n  animationData.name = generateNextCustomKeyframeName();\n  const parsedKeyframe = convertAnimationObjectToKeyframes(animationData);\n  insertWebAnimation(animationData.name, parsedKeyframe);\n  return animationData.name;\n}\nexport function createAnimationWithInitialValues(animationName, initialValues) {\n  const animationStyle = structuredClone(AnimationsData[animationName].style);\n  const firstAnimationStep = animationStyle['0'];\n  const {\n      transform\n    } = initialValues,\n    rest = _objectWithoutPropertiesLoose(initialValues, _excluded);\n  const transformWithPx = addPxToTransform(transform);\n  if (transform) {\n    if (!firstAnimationStep.transform) {\n      firstAnimationStep.transform = transformWithPx;\n    } else {\n      const transformStyle = new Map();\n      for (const rule of firstAnimationStep.transform) {\n        for (const [property, value] of Object.entries(rule)) {\n          transformStyle.set(property, value);\n        }\n      }\n      for (const rule of transformWithPx) {\n        for (const [property, value] of Object.entries(rule)) {\n          transformStyle.set(property, value);\n        }\n      }\n      firstAnimationStep.transform = Array.from(transformStyle, ([property, value]) => ({\n        [property]: value\n      }));\n    }\n  }\n  animationStyle['0'] = Object.assign({}, animationStyle['0'], rest);\n  const keyframeName = generateNextCustomKeyframeName();\n  const animationObject = {\n    name: keyframeName,\n    style: animationStyle,\n    duration: AnimationsData[animationName].duration\n  };\n  const keyframe = convertAnimationObjectToKeyframes(animationObject);\n  insertWebAnimation(keyframeName, keyframe);\n  return keyframeName;\n}\nlet customKeyframeCounter = 0;\nfunction generateNextCustomKeyframeName() {\n  return `REA${customKeyframeCounter++}`;\n}\nexport function TransitionGenerator(transitionType, transitionData) {\n  const transitionKeyframeName = generateNextCustomKeyframeName();\n  let dummyTransitionKeyframeName;\n  let transitionObject;\n  switch (transitionType) {\n    case TransitionType.LINEAR:\n      transitionObject = LinearTransition(transitionKeyframeName, transitionData);\n      break;\n    case TransitionType.SEQUENCED:\n      transitionObject = SequencedTransition(transitionKeyframeName, transitionData);\n      break;\n    case TransitionType.FADING:\n      transitionObject = FadingTransition(transitionKeyframeName, transitionData);\n      break;\n    case TransitionType.JUMPING:\n      transitionObject = JumpingTransition(transitionKeyframeName, transitionData);\n      break;\n    case TransitionType.CURVED:\n      {\n        dummyTransitionKeyframeName = generateNextCustomKeyframeName();\n        const {\n          firstKeyframeObj,\n          secondKeyframeObj\n        } = CurvedTransition(transitionKeyframeName, dummyTransitionKeyframeName, transitionData);\n        transitionObject = firstKeyframeObj;\n        const dummyKeyframe = convertAnimationObjectToKeyframes(secondKeyframeObj);\n        insertWebAnimation(dummyTransitionKeyframeName, dummyKeyframe);\n        break;\n      }\n    case TransitionType.ENTRY_EXIT:\n      transitionObject = EntryExitTransition(transitionKeyframeName, transitionData);\n      break;\n  }\n  const transitionKeyframe = convertAnimationObjectToKeyframes(transitionObject);\n  insertWebAnimation(transitionKeyframeName, transitionKeyframe);\n  return {\n    transitionKeyframeName,\n    dummyTransitionKeyframeName\n  };\n}","map":{"version":3,"names":["_objectWithoutPropertiesLoose","_excluded","AnimationsData","TransitionType","convertAnimationObjectToKeyframes","LinearTransition","SequencedTransition","FadingTransition","JumpingTransition","insertWebAnimation","CurvedTransition","EntryExitTransition","addPxToTransform","transform","newTransform","map","transformProp","newTransformProp","key","value","Object","entries","includes","createCustomKeyFrameAnimation","keyframeDefinitions","values","animationData","name","style","duration","generateNextCustomKeyframeName","parsedKeyframe","createAnimationWithInitialValues","animationName","initialValues","animationStyle","structuredClone","firstAnimationStep","rest","transformWithPx","transformStyle","Map","rule","property","set","Array","from","assign","keyframeName","animationObject","keyframe","customKeyframeCounter","TransitionGenerator","transitionType","transitionData","transitionKeyframeName","dummyTransitionKeyframeName","transitionObject","LINEAR","SEQUENCED","FADING","JUMPING","CURVED","firstKeyframeObj","secondKeyframeObj","dummyKeyframe","ENTRY_EXIT","transitionKeyframe"],"sources":["C:\\Users\\user\\OneDrive\\Documents\\rn\\l\\node_modules\\react-native-reanimated\\lib\\module\\layoutReanimation\\web\\createAnimation.ts"],"sourcesContent":["'use strict';\n\nimport { AnimationsData, TransitionType } from './config';\nimport type { InitialValuesStyleProps, KeyframeDefinitions } from './config';\nimport { convertAnimationObjectToKeyframes } from './animationParser';\nimport type {\n  AnimationData,\n  ReanimatedWebTransformProperties,\n  TransitionData,\n} from './animationParser';\nimport type { TransformsStyle } from 'react-native';\nimport { LinearTransition } from './transition/Linear.web';\nimport { SequencedTransition } from './transition/Sequenced.web';\nimport { FadingTransition } from './transition/Fading.web';\nimport { JumpingTransition } from './transition/Jumping.web';\nimport { insertWebAnimation } from './domUtils';\nimport { CurvedTransition } from './transition/Curved.web';\nimport { EntryExitTransition } from './transition/EntryExit.web';\n\ntype TransformType = NonNullable<TransformsStyle['transform']>;\n\n// Translate values are passed as numbers. However, if `translate` property receives number, it will not automatically\n// convert it to `px`. Therefore if we want to keep transform we have to add 'px' suffix to each of translate values\n// that are present inside transform.\n//\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction addPxToTransform(transform: TransformType) {\n  type RNTransformProp = (typeof transform)[number];\n\n  // @ts-ignore `existingTransform` cannot be string because in that case\n  // we throw error in `extractTransformFromStyle`\n  const newTransform = transform.map((transformProp: RNTransformProp) => {\n    const newTransformProp: ReanimatedWebTransformProperties = {};\n    for (const [key, value] of Object.entries(transformProp)) {\n      if (\n        (key.includes('translate') || key.includes('perspective')) &&\n        typeof value === 'number'\n      ) {\n        // @ts-ignore After many trials we decided to ignore this error - it says that we cannot use 'key' to index this object.\n        // Sadly it doesn't go away after using cast `key as keyof TransformProperties`.\n        newTransformProp[key] = `${value}px`;\n      } else {\n        // @ts-ignore same as above.\n        newTransformProp[key] = value;\n      }\n    }\n    return newTransformProp;\n  });\n\n  return newTransform;\n}\n\nexport function createCustomKeyFrameAnimation(\n  keyframeDefinitions: KeyframeDefinitions\n) {\n  for (const value of Object.values(keyframeDefinitions)) {\n    if (value.transform) {\n      value.transform = addPxToTransform(value.transform as TransformType);\n    }\n  }\n\n  const animationData: AnimationData = {\n    name: '',\n    style: keyframeDefinitions,\n    duration: -1,\n  };\n\n  animationData.name = generateNextCustomKeyframeName();\n\n  const parsedKeyframe = convertAnimationObjectToKeyframes(animationData);\n\n  insertWebAnimation(animationData.name, parsedKeyframe);\n\n  return animationData.name;\n}\n\nexport function createAnimationWithInitialValues(\n  animationName: string,\n  initialValues: InitialValuesStyleProps\n) {\n  const animationStyle = structuredClone(AnimationsData[animationName].style);\n  const firstAnimationStep = animationStyle['0'];\n\n  const { transform, ...rest } = initialValues;\n  const transformWithPx = addPxToTransform(transform as TransformType);\n\n  if (transform) {\n    // If there was no predefined transform, we can simply assign transform from `initialValues`.\n    if (!firstAnimationStep.transform) {\n      firstAnimationStep.transform = transformWithPx;\n    } else {\n      // Othwerwise we have to merge predefined transform with the one provided in `initialValues`.\n      // To do that, we create `Map` that will contain final transform.\n      const transformStyle = new Map<string, any>();\n\n      // First we assign all of the predefined rules\n      for (const rule of firstAnimationStep.transform) {\n        // In most cases there will be just one iteration\n        for (const [property, value] of Object.entries(rule)) {\n          transformStyle.set(property, value);\n        }\n      }\n\n      // Then we either add new rule, or override one that already exists.\n      for (const rule of transformWithPx) {\n        for (const [property, value] of Object.entries(rule)) {\n          transformStyle.set(property, value);\n        }\n      }\n\n      // Finally, we convert `Map` with final transform back into array of objects.\n      firstAnimationStep.transform = Array.from(\n        transformStyle,\n        ([property, value]) => ({\n          [property]: value,\n        })\n      );\n    }\n  }\n\n  animationStyle['0'] = {\n    ...animationStyle['0'],\n    ...rest,\n  };\n\n  // TODO: Maybe we can extract the logic below into separate function\n  const keyframeName = generateNextCustomKeyframeName();\n\n  const animationObject: AnimationData = {\n    name: keyframeName,\n    style: animationStyle,\n    duration: AnimationsData[animationName].duration,\n  };\n\n  const keyframe = convertAnimationObjectToKeyframes(animationObject);\n\n  insertWebAnimation(keyframeName, keyframe);\n\n  return keyframeName;\n}\n\nlet customKeyframeCounter = 0;\n\nfunction generateNextCustomKeyframeName() {\n  return `REA${customKeyframeCounter++}`;\n}\n\n/**\n * Creates transition of given type, appends it to stylesheet and returns keyframe name.\n *\n * @param transitionType - Type of transition (e.g. LINEAR).\n * @param transitionData - Object containing data for transforms (translateX, scaleX,...).\n * @returns Keyframe name that represents transition.\n */\nexport function TransitionGenerator(\n  transitionType: TransitionType,\n  transitionData: TransitionData\n) {\n  const transitionKeyframeName = generateNextCustomKeyframeName();\n  let dummyTransitionKeyframeName;\n\n  let transitionObject;\n\n  switch (transitionType) {\n    case TransitionType.LINEAR:\n      transitionObject = LinearTransition(\n        transitionKeyframeName,\n        transitionData\n      );\n      break;\n    case TransitionType.SEQUENCED:\n      transitionObject = SequencedTransition(\n        transitionKeyframeName,\n        transitionData\n      );\n      break;\n    case TransitionType.FADING:\n      transitionObject = FadingTransition(\n        transitionKeyframeName,\n        transitionData\n      );\n      break;\n    case TransitionType.JUMPING:\n      transitionObject = JumpingTransition(\n        transitionKeyframeName,\n        transitionData\n      );\n      break;\n\n    // Here code block with {} is necessary because of eslint\n    case TransitionType.CURVED: {\n      dummyTransitionKeyframeName = generateNextCustomKeyframeName();\n\n      const { firstKeyframeObj, secondKeyframeObj } = CurvedTransition(\n        transitionKeyframeName,\n        dummyTransitionKeyframeName,\n        transitionData\n      );\n\n      transitionObject = firstKeyframeObj;\n\n      const dummyKeyframe =\n        convertAnimationObjectToKeyframes(secondKeyframeObj);\n\n      insertWebAnimation(dummyTransitionKeyframeName, dummyKeyframe);\n\n      break;\n    }\n    case TransitionType.ENTRY_EXIT:\n      transitionObject = EntryExitTransition(\n        transitionKeyframeName,\n        transitionData\n      );\n      break;\n  }\n\n  const transitionKeyframe =\n    convertAnimationObjectToKeyframes(transitionObject);\n\n  insertWebAnimation(transitionKeyframeName, transitionKeyframe);\n\n  return { transitionKeyframeName, dummyTransitionKeyframeName };\n}\n"],"mappings":"AAAA,YAAY;;AAAA,OAAAA,6BAAA;AAAA,MAAAC,SAAA;AAEZ,SAASC,cAAc,EAAEC,cAAc,QAAQ,UAAU;AAEzD,SAASC,iCAAiC,QAAQ,mBAAmB;AAOrE,SAASC,gBAAgB,QAAQ,yBAAyB;AAC1D,SAASC,mBAAmB,QAAQ,4BAA4B;AAChE,SAASC,gBAAgB,QAAQ,yBAAyB;AAC1D,SAASC,iBAAiB,QAAQ,0BAA0B;AAC5D,SAASC,kBAAkB,QAAQ,YAAY;AAC/C,SAASC,gBAAgB,QAAQ,yBAAyB;AAC1D,SAASC,mBAAmB,QAAQ,4BAA4B;AAShE,SAASC,gBAAgBA,CAACC,SAAwB,EAAE;EAKlD,MAAMC,YAAY,GAAGD,SAAS,CAACE,GAAG,CAAEC,aAA8B,IAAK;IACrE,MAAMC,gBAAkD,GAAG,CAAC,CAAC;IAC7D,KAAK,MAAM,CAACC,GAAG,EAAEC,KAAK,CAAC,IAAIC,MAAM,CAACC,OAAO,CAACL,aAAa,CAAC,EAAE;MACxD,IACE,CAACE,GAAG,CAACI,QAAQ,CAAC,WAAW,CAAC,IAAIJ,GAAG,CAACI,QAAQ,CAAC,aAAa,CAAC,KACzD,OAAOH,KAAK,KAAK,QAAQ,EACzB;QAGAF,gBAAgB,CAACC,GAAG,CAAC,GAAI,GAAEC,KAAM,IAAG;MACtC,CAAC,MAAM;QAELF,gBAAgB,CAACC,GAAG,CAAC,GAAGC,KAAK;MAC/B;IACF;IACA,OAAOF,gBAAgB;EACzB,CAAC,CAAC;EAEF,OAAOH,YAAY;AACrB;AAEA,OAAO,SAASS,6BAA6BA,CAC3CC,mBAAwC,EACxC;EACA,KAAK,MAAML,KAAK,IAAIC,MAAM,CAACK,MAAM,CAACD,mBAAmB,CAAC,EAAE;IACtD,IAAIL,KAAK,CAACN,SAAS,EAAE;MACnBM,KAAK,CAACN,SAAS,GAAGD,gBAAgB,CAACO,KAAK,CAACN,SAA0B,CAAC;IACtE;EACF;EAEA,MAAMa,aAA4B,GAAG;IACnCC,IAAI,EAAE,EAAE;IACRC,KAAK,EAAEJ,mBAAmB;IAC1BK,QAAQ,EAAE,CAAC;EACb,CAAC;EAEDH,aAAa,CAACC,IAAI,GAAGG,8BAA8B,CAAC,CAAC;EAErD,MAAMC,cAAc,GAAG3B,iCAAiC,CAACsB,aAAa,CAAC;EAEvEjB,kBAAkB,CAACiB,aAAa,CAACC,IAAI,EAAEI,cAAc,CAAC;EAEtD,OAAOL,aAAa,CAACC,IAAI;AAC3B;AAEA,OAAO,SAASK,gCAAgCA,CAC9CC,aAAqB,EACrBC,aAAsC,EACtC;EACA,MAAMC,cAAc,GAAGC,eAAe,CAAClC,cAAc,CAAC+B,aAAa,CAAC,CAACL,KAAK,CAAC;EAC3E,MAAMS,kBAAkB,GAAGF,cAAc,CAAC,GAAG,CAAC;EAE9C,MAAM;MAAEtB;IAAmB,CAAC,GAAGqB,aAAa;IAAtBI,IAAA,GAAAtC,6BAAA,CAASkC,aAAa,EAAAjC,SAAA;EAC5C,MAAMsC,eAAe,GAAG3B,gBAAgB,CAACC,SAA0B,CAAC;EAEpE,IAAIA,SAAS,EAAE;IAEb,IAAI,CAACwB,kBAAkB,CAACxB,SAAS,EAAE;MACjCwB,kBAAkB,CAACxB,SAAS,GAAG0B,eAAe;IAChD,CAAC,MAAM;MAGL,MAAMC,cAAc,GAAG,IAAIC,GAAG,CAAc,CAAC;MAG7C,KAAK,MAAMC,IAAI,IAAIL,kBAAkB,CAACxB,SAAS,EAAE;QAE/C,KAAK,MAAM,CAAC8B,QAAQ,EAAExB,KAAK,CAAC,IAAIC,MAAM,CAACC,OAAO,CAACqB,IAAI,CAAC,EAAE;UACpDF,cAAc,CAACI,GAAG,CAACD,QAAQ,EAAExB,KAAK,CAAC;QACrC;MACF;MAGA,KAAK,MAAMuB,IAAI,IAAIH,eAAe,EAAE;QAClC,KAAK,MAAM,CAACI,QAAQ,EAAExB,KAAK,CAAC,IAAIC,MAAM,CAACC,OAAO,CAACqB,IAAI,CAAC,EAAE;UACpDF,cAAc,CAACI,GAAG,CAACD,QAAQ,EAAExB,KAAK,CAAC;QACrC;MACF;MAGAkB,kBAAkB,CAACxB,SAAS,GAAGgC,KAAK,CAACC,IAAI,CACvCN,cAAc,EACd,CAAC,CAACG,QAAQ,EAAExB,KAAK,CAAC,MAAM;QACtB,CAACwB,QAAQ,GAAGxB;MACd,CAAC,CACH,CAAC;IACH;EACF;EAEAgB,cAAc,CAAC,GAAG,CAAC,GAAAf,MAAA,CAAA2B,MAAA,KACdZ,cAAc,CAAC,GAAG,CAAC,EACnBG,IAAA,CACJ;EAGD,MAAMU,YAAY,GAAGlB,8BAA8B,CAAC,CAAC;EAErD,MAAMmB,eAA8B,GAAG;IACrCtB,IAAI,EAAEqB,YAAY;IAClBpB,KAAK,EAAEO,cAAc;IACrBN,QAAQ,EAAE3B,cAAc,CAAC+B,aAAa,CAAC,CAACJ;EAC1C,CAAC;EAED,MAAMqB,QAAQ,GAAG9C,iCAAiC,CAAC6C,eAAe,CAAC;EAEnExC,kBAAkB,CAACuC,YAAY,EAAEE,QAAQ,CAAC;EAE1C,OAAOF,YAAY;AACrB;AAEA,IAAIG,qBAAqB,GAAG,CAAC;AAE7B,SAASrB,8BAA8BA,CAAA,EAAG;EACxC,OAAQ,MAAKqB,qBAAqB,EAAG,EAAC;AACxC;AASA,OAAO,SAASC,mBAAmBA,CACjCC,cAA8B,EAC9BC,cAA8B,EAC9B;EACA,MAAMC,sBAAsB,GAAGzB,8BAA8B,CAAC,CAAC;EAC/D,IAAI0B,2BAA2B;EAE/B,IAAIC,gBAAgB;EAEpB,QAAQJ,cAAc;IACpB,KAAKlD,cAAc,CAACuD,MAAM;MACxBD,gBAAgB,GAAGpD,gBAAgB,CACjCkD,sBAAsB,EACtBD,cACF,CAAC;MACD;IACF,KAAKnD,cAAc,CAACwD,SAAS;MAC3BF,gBAAgB,GAAGnD,mBAAmB,CACpCiD,sBAAsB,EACtBD,cACF,CAAC;MACD;IACF,KAAKnD,cAAc,CAACyD,MAAM;MACxBH,gBAAgB,GAAGlD,gBAAgB,CACjCgD,sBAAsB,EACtBD,cACF,CAAC;MACD;IACF,KAAKnD,cAAc,CAAC0D,OAAO;MACzBJ,gBAAgB,GAAGjD,iBAAiB,CAClC+C,sBAAsB,EACtBD,cACF,CAAC;MACD;IAGF,KAAKnD,cAAc,CAAC2D,MAAM;MAAE;QAC1BN,2BAA2B,GAAG1B,8BAA8B,CAAC,CAAC;QAE9D,MAAM;UAAEiC,gBAAgB;UAAEC;QAAkB,CAAC,GAAGtD,gBAAgB,CAC9D6C,sBAAsB,EACtBC,2BAA2B,EAC3BF,cACF,CAAC;QAEDG,gBAAgB,GAAGM,gBAAgB;QAEnC,MAAME,aAAa,GACjB7D,iCAAiC,CAAC4D,iBAAiB,CAAC;QAEtDvD,kBAAkB,CAAC+C,2BAA2B,EAAES,aAAa,CAAC;QAE9D;MACF;IACA,KAAK9D,cAAc,CAAC+D,UAAU;MAC5BT,gBAAgB,GAAG9C,mBAAmB,CACpC4C,sBAAsB,EACtBD,cACF,CAAC;MACD;EACJ;EAEA,MAAMa,kBAAkB,GACtB/D,iCAAiC,CAACqD,gBAAgB,CAAC;EAErDhD,kBAAkB,CAAC8C,sBAAsB,EAAEY,kBAAkB,CAAC;EAE9D,OAAO;IAAEZ,sBAAsB;IAAEC;EAA4B,CAAC;AAChE","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}