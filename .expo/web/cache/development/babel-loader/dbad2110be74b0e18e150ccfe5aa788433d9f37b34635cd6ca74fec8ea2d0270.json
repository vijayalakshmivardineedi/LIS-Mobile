{"ast":null,"code":"import React, { useContext, useEffect, useLayoutEffect, useMemo, useRef } from 'react';\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport findNodeHandle from \"react-native-web/dist/exports/findNodeHandle\";\nimport { isJestEnv } from '../../../utils';\nimport GestureHandlerRootViewContext from '../../../GestureHandlerRootViewContext';\nimport { useAnimatedGesture } from './useAnimatedGesture';\nimport { attachHandlers } from './attachHandlers';\nimport { needsToReattach } from './needsToReattach';\nimport { dropHandlers } from './dropHandlers';\nimport { useWebEventHandlers } from './utils';\nimport { Wrap, AnimatedWrap } from './Wrap';\nimport { useDetectorUpdater } from './useDetectorUpdater';\nimport { useViewRefHandler } from './useViewRefHandler';\nfunction propagateDetectorConfig(props, gesture) {\n  const keysToPropagate = ['userSelect', 'enableContextMenu', 'touchAction'];\n  for (const key of keysToPropagate) {\n    const value = props[key];\n    if (value === undefined) {\n      continue;\n    }\n    for (const g of gesture.toGestureArray()) {\n      const config = g.config;\n      config[key] = value;\n    }\n  }\n}\nexport const GestureDetector = props => {\n  const rootViewContext = useContext(GestureHandlerRootViewContext);\n  if (__DEV__ && !rootViewContext && !isJestEnv() && Platform.OS !== 'web') {\n    throw new Error('GestureDetector must be used as a descendant of GestureHandlerRootView. Otherwise the gestures will not be recognized. See https://docs.swmansion.com/react-native-gesture-handler/docs/installation for more details.');\n  }\n  const gestureConfig = props.gesture;\n  propagateDetectorConfig(props, gestureConfig);\n  const gesturesToAttach = useMemo(() => gestureConfig.toGestureArray(), [gestureConfig]);\n  const shouldUseReanimated = gesturesToAttach.some(g => g.shouldUseReanimated);\n  const webEventHandlersRef = useWebEventHandlers();\n  const state = useRef({\n    firstRender: true,\n    viewRef: null,\n    previousViewTag: -1,\n    forceRebuildReanimatedEvent: false\n  }).current;\n  const preparedGesture = React.useRef({\n    attachedGestures: [],\n    animatedEventHandler: null,\n    animatedHandlers: null,\n    shouldUseReanimated: shouldUseReanimated,\n    isMounted: false\n  }).current;\n  const updateAttachedGestures = useDetectorUpdater(state, preparedGesture, gesturesToAttach, gestureConfig, webEventHandlersRef);\n  const refHandler = useViewRefHandler(state, updateAttachedGestures);\n  const needsToRebuildReanimatedEvent = state.firstRender || state.forceRebuildReanimatedEvent || needsToReattach(preparedGesture, gesturesToAttach);\n  state.forceRebuildReanimatedEvent = false;\n  useAnimatedGesture(preparedGesture, needsToRebuildReanimatedEvent);\n  useLayoutEffect(() => {\n    const viewTag = findNodeHandle(state.viewRef);\n    preparedGesture.isMounted = true;\n    attachHandlers({\n      preparedGesture,\n      gestureConfig,\n      gesturesToAttach,\n      webEventHandlersRef,\n      viewTag\n    });\n    return () => {\n      preparedGesture.isMounted = false;\n      dropHandlers(preparedGesture);\n    };\n  }, []);\n  useEffect(() => {\n    if (state.firstRender) {\n      state.firstRender = false;\n    } else {\n      updateAttachedGestures();\n    }\n  }, [props]);\n  if (shouldUseReanimated) {\n    return React.createElement(AnimatedWrap, {\n      ref: refHandler,\n      onGestureHandlerEvent: preparedGesture.animatedEventHandler\n    }, props.children);\n  } else {\n    return React.createElement(Wrap, {\n      ref: refHandler\n    }, props.children);\n  }\n};","map":{"version":3,"names":["React","useContext","useEffect","useLayoutEffect","useMemo","useRef","Platform","findNodeHandle","isJestEnv","GestureHandlerRootViewContext","useAnimatedGesture","attachHandlers","needsToReattach","dropHandlers","useWebEventHandlers","Wrap","AnimatedWrap","useDetectorUpdater","useViewRefHandler","propagateDetectorConfig","props","gesture","keysToPropagate","key","value","undefined","g","toGestureArray","config","GestureDetector","rootViewContext","__DEV__","OS","Error","gestureConfig","gesturesToAttach","shouldUseReanimated","some","webEventHandlersRef","state","firstRender","viewRef","previousViewTag","forceRebuildReanimatedEvent","current","preparedGesture","attachedGestures","animatedEventHandler","animatedHandlers","isMounted","updateAttachedGestures","refHandler","needsToRebuildReanimatedEvent","viewTag","createElement","ref","onGestureHandlerEvent","children"],"sources":["C:\\Users\\user\\OneDrive\\Documents\\rn\\l\\node_modules\\react-native-gesture-handler\\lib\\module\\handlers\\gestures\\GestureDetector\\index.tsx"],"sourcesContent":["/* eslint-disable react/no-unused-prop-types */\nimport React, {\n  useContext,\n  useEffect,\n  useLayoutEffect,\n  useMemo,\n  useRef,\n} from 'react';\nimport { Platform, findNodeHandle } from 'react-native';\nimport { GestureType } from '../gesture';\nimport { UserSelect, TouchAction } from '../../gestureHandlerCommon';\nimport { ComposedGesture } from '../gestureComposition';\nimport { isJestEnv } from '../../../utils';\n\nimport GestureHandlerRootViewContext from '../../../GestureHandlerRootViewContext';\nimport { AttachedGestureState, GestureDetectorState } from './types';\nimport { useAnimatedGesture } from './useAnimatedGesture';\nimport { attachHandlers } from './attachHandlers';\nimport { needsToReattach } from './needsToReattach';\nimport { dropHandlers } from './dropHandlers';\nimport { useWebEventHandlers } from './utils';\nimport { Wrap, AnimatedWrap } from './Wrap';\nimport { useDetectorUpdater } from './useDetectorUpdater';\nimport { useViewRefHandler } from './useViewRefHandler';\n\nfunction propagateDetectorConfig(\n  props: GestureDetectorProps,\n  gesture: ComposedGesture | GestureType\n) {\n  const keysToPropagate: (keyof GestureDetectorProps)[] = [\n    'userSelect',\n    'enableContextMenu',\n    'touchAction',\n  ];\n\n  for (const key of keysToPropagate) {\n    const value = props[key];\n    if (value === undefined) {\n      continue;\n    }\n\n    for (const g of gesture.toGestureArray()) {\n      const config = g.config as { [key: string]: unknown };\n      config[key] = value;\n    }\n  }\n}\n\ninterface GestureDetectorProps {\n  children?: React.ReactNode;\n  /**\n   * A gesture object containing the configuration and callbacks.\n   * Can be any of:\n   * - base gestures (`Tap`, `Pan`, ...)\n   * - `ComposedGesture` (`Race`, `Simultaneous`, `Exclusive`)\n   */\n  gesture: ComposedGesture | GestureType;\n  /**\n   * #### Web only\n   * This parameter allows to specify which `userSelect` property should be applied to underlying view.\n   * Possible values are `\"none\" | \"auto\" | \"text\"`. Default value is set to `\"none\"`.\n   */\n  userSelect?: UserSelect;\n  /**\n   * #### Web only\n   * Specifies whether context menu should be enabled after clicking on underlying view with right mouse button.\n   * Default value is set to `false`.\n   */\n  enableContextMenu?: boolean;\n  /**\n   * #### Web only\n   * This parameter allows to specify which `touchAction` property should be applied to underlying view.\n   * Supports all CSS touch-action values (e.g. `\"none\"`, `\"pan-y\"`). Default value is set to `\"none\"`.\n   */\n  touchAction?: TouchAction;\n}\n\n/**\n * `GestureDetector` is responsible for creating and updating native gesture handlers based on the config of provided gesture.\n *\n * ### Props\n * - `gesture`\n * - `userSelect` (**Web only**)\n * - `enableContextMenu` (**Web only**)\n * - `touchAction` (**Web only**)\n *\n * ### Remarks\n * - Gesture Detector will use first native view in its subtree to recognize gestures, however if this view is used only to group its children it may get automatically collapsed.\n * - Using the same instance of a gesture across multiple Gesture Detectors is not possible.\n *\n * @see https://docs.swmansion.com/react-native-gesture-handler/docs/gestures/gesture-detector\n */\nexport const GestureDetector = (props: GestureDetectorProps) => {\n  const rootViewContext = useContext(GestureHandlerRootViewContext);\n  if (__DEV__ && !rootViewContext && !isJestEnv() && Platform.OS !== 'web') {\n    throw new Error(\n      'GestureDetector must be used as a descendant of GestureHandlerRootView. Otherwise the gestures will not be recognized. See https://docs.swmansion.com/react-native-gesture-handler/docs/installation for more details.'\n    );\n  }\n\n  // Gesture config should be wrapped with useMemo to prevent unnecessary re-renders\n  const gestureConfig = props.gesture;\n  propagateDetectorConfig(props, gestureConfig);\n\n  const gesturesToAttach = useMemo(\n    () => gestureConfig.toGestureArray(),\n    [gestureConfig]\n  );\n  const shouldUseReanimated = gesturesToAttach.some(\n    (g) => g.shouldUseReanimated\n  );\n\n  const webEventHandlersRef = useWebEventHandlers();\n  // Store state in ref to prevent unnecessary renders\n  const state = useRef<GestureDetectorState>({\n    firstRender: true,\n    viewRef: null,\n    previousViewTag: -1,\n    forceRebuildReanimatedEvent: false,\n  }).current;\n\n  const preparedGesture = React.useRef<AttachedGestureState>({\n    attachedGestures: [],\n    animatedEventHandler: null,\n    animatedHandlers: null,\n    shouldUseReanimated: shouldUseReanimated,\n    isMounted: false,\n  }).current;\n\n  const updateAttachedGestures = useDetectorUpdater(\n    state,\n    preparedGesture,\n    gesturesToAttach,\n    gestureConfig,\n    webEventHandlersRef\n  );\n\n  const refHandler = useViewRefHandler(state, updateAttachedGestures);\n\n  // Reanimated event should be rebuilt only when gestures are reattached, otherwise\n  // config update will be enough as all necessary items are stored in shared values anyway\n  const needsToRebuildReanimatedEvent =\n    state.firstRender ||\n    state.forceRebuildReanimatedEvent ||\n    needsToReattach(preparedGesture, gesturesToAttach);\n  state.forceRebuildReanimatedEvent = false;\n\n  useAnimatedGesture(preparedGesture, needsToRebuildReanimatedEvent);\n\n  useLayoutEffect(() => {\n    const viewTag = findNodeHandle(state.viewRef) as number;\n    preparedGesture.isMounted = true;\n\n    attachHandlers({\n      preparedGesture,\n      gestureConfig,\n      gesturesToAttach,\n      webEventHandlersRef,\n      viewTag,\n    });\n\n    return () => {\n      preparedGesture.isMounted = false;\n      dropHandlers(preparedGesture);\n    };\n  }, []);\n\n  useEffect(() => {\n    if (state.firstRender) {\n      state.firstRender = false;\n    } else {\n      updateAttachedGestures();\n    }\n  }, [props]);\n\n  if (shouldUseReanimated) {\n    return (\n      <AnimatedWrap\n        ref={refHandler}\n        onGestureHandlerEvent={preparedGesture.animatedEventHandler}>\n        {props.children}\n      </AnimatedWrap>\n    );\n  } else {\n    return <Wrap ref={refHandler}>{props.children}</Wrap>;\n  }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}