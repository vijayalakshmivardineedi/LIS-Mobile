{"ast":null,"code":"function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nimport { EventTypes } from '../interfaces';\nexport default class RotationGestureDetector {\n  constructor(callbacks) {\n    _defineProperty(this, \"onRotationBegin\", void 0);\n    _defineProperty(this, \"onRotation\", void 0);\n    _defineProperty(this, \"onRotationEnd\", void 0);\n    _defineProperty(this, \"currentTime\", 0);\n    _defineProperty(this, \"previousTime\", 0);\n    _defineProperty(this, \"previousAngle\", 0);\n    _defineProperty(this, \"rotation\", 0);\n    _defineProperty(this, \"anchorX\", 0);\n    _defineProperty(this, \"anchorY\", 0);\n    _defineProperty(this, \"isInProgress\", false);\n    _defineProperty(this, \"keyPointers\", [NaN, NaN]);\n    this.onRotationBegin = callbacks.onRotationBegin;\n    this.onRotation = callbacks.onRotation;\n    this.onRotationEnd = callbacks.onRotationEnd;\n  }\n  updateCurrent(event, tracker) {\n    this.previousTime = this.currentTime;\n    this.currentTime = event.time;\n    const [firstPointerID, secondPointerID] = this.keyPointers;\n    const firstPointerCoords = tracker.getLastAbsoluteCoords(firstPointerID);\n    const secondPointerCoords = tracker.getLastAbsoluteCoords(secondPointerID);\n    const vectorX = secondPointerCoords.x - firstPointerCoords.x;\n    const vectorY = secondPointerCoords.y - firstPointerCoords.y;\n    this.anchorX = (firstPointerCoords.x + secondPointerCoords.x) / 2;\n    this.anchorY = (firstPointerCoords.y + secondPointerCoords.y) / 2;\n    const angle = -Math.atan2(vectorY, vectorX);\n    this.rotation = Number.isNaN(this.previousAngle) ? 0 : this.previousAngle - angle;\n    this.previousAngle = angle;\n    if (this.rotation > Math.PI) {\n      this.rotation -= Math.PI;\n    } else if (this.rotation < -Math.PI) {\n      this.rotation += Math.PI;\n    }\n    if (this.rotation > Math.PI / 2) {\n      this.rotation -= Math.PI;\n    } else if (this.rotation < -Math.PI / 2) {\n      this.rotation += Math.PI;\n    }\n  }\n  finish() {\n    if (!this.isInProgress) {\n      return;\n    }\n    this.isInProgress = false;\n    this.keyPointers = [NaN, NaN];\n    this.onRotationEnd(this);\n  }\n  setKeyPointers(tracker) {\n    if (this.keyPointers[0] && this.keyPointers[1]) {\n      return;\n    }\n    const pointerIDs = tracker.getData().keys();\n    this.keyPointers[0] = pointerIDs.next().value;\n    this.keyPointers[1] = pointerIDs.next().value;\n  }\n  onTouchEvent(event, tracker) {\n    switch (event.eventType) {\n      case EventTypes.DOWN:\n        this.isInProgress = false;\n        break;\n      case EventTypes.ADDITIONAL_POINTER_DOWN:\n        if (this.isInProgress) {\n          break;\n        }\n        this.isInProgress = true;\n        this.previousTime = event.time;\n        this.previousAngle = NaN;\n        this.setKeyPointers(tracker);\n        this.updateCurrent(event, tracker);\n        this.onRotationBegin(this);\n        break;\n      case EventTypes.MOVE:\n        if (!this.isInProgress) {\n          break;\n        }\n        this.updateCurrent(event, tracker);\n        this.onRotation(this);\n        break;\n      case EventTypes.ADDITIONAL_POINTER_UP:\n        if (!this.isInProgress) {\n          break;\n        }\n        if (this.keyPointers.indexOf(event.pointerId) >= 0) {\n          this.finish();\n        }\n        break;\n      case EventTypes.UP:\n        if (this.isInProgress) {\n          this.finish();\n        }\n        break;\n    }\n    return true;\n  }\n  getTimeDelta() {\n    return this.currentTime + this.previousTime;\n  }\n  getAnchorX() {\n    return this.anchorX;\n  }\n  getAnchorY() {\n    return this.anchorY;\n  }\n  getRotation() {\n    return this.rotation;\n  }\n  reset() {\n    this.keyPointers = [NaN, NaN];\n    this.isInProgress = false;\n  }\n}","map":{"version":3,"names":["EventTypes","RotationGestureDetector","constructor","callbacks","_defineProperty","NaN","onRotationBegin","onRotation","onRotationEnd","updateCurrent","event","tracker","previousTime","currentTime","time","firstPointerID","secondPointerID","keyPointers","firstPointerCoords","getLastAbsoluteCoords","secondPointerCoords","vectorX","x","vectorY","y","anchorX","anchorY","angle","Math","atan2","rotation","Number","isNaN","previousAngle","PI","finish","isInProgress","setKeyPointers","pointerIDs","getData","keys","next","value","onTouchEvent","eventType","DOWN","ADDITIONAL_POINTER_DOWN","MOVE","ADDITIONAL_POINTER_UP","indexOf","pointerId","UP","getTimeDelta","getAnchorX","getAnchorY","getRotation","reset"],"sources":["C:\\Users\\user\\OneDrive\\Documents\\rn\\l\\node_modules\\react-native-gesture-handler\\lib\\module\\web\\detectors\\RotationGestureDetector.ts"],"sourcesContent":["import { AdaptedEvent, EventTypes } from '../interfaces';\nimport PointerTracker from '../tools/PointerTracker';\n\nexport interface RotationGestureListener {\n  onRotationBegin: (detector: RotationGestureDetector) => boolean;\n  onRotation: (detector: RotationGestureDetector) => boolean;\n  onRotationEnd: (detector: RotationGestureDetector) => void;\n}\n\nexport default class RotationGestureDetector\n  implements RotationGestureListener\n{\n  onRotationBegin: (detector: RotationGestureDetector) => boolean;\n  onRotation: (detector: RotationGestureDetector) => boolean;\n  onRotationEnd: (detector: RotationGestureDetector) => void;\n\n  private currentTime = 0;\n  private previousTime = 0;\n\n  private previousAngle = 0;\n  private rotation = 0;\n\n  private anchorX = 0;\n  private anchorY = 0;\n\n  private isInProgress = false;\n\n  private keyPointers: number[] = [NaN, NaN];\n\n  constructor(callbacks: RotationGestureListener) {\n    this.onRotationBegin = callbacks.onRotationBegin;\n    this.onRotation = callbacks.onRotation;\n    this.onRotationEnd = callbacks.onRotationEnd;\n  }\n\n  private updateCurrent(event: AdaptedEvent, tracker: PointerTracker): void {\n    this.previousTime = this.currentTime;\n    this.currentTime = event.time;\n\n    const [firstPointerID, secondPointerID] = this.keyPointers;\n\n    const firstPointerCoords = tracker.getLastAbsoluteCoords(firstPointerID);\n    const secondPointerCoords = tracker.getLastAbsoluteCoords(secondPointerID);\n\n    const vectorX: number = secondPointerCoords.x - firstPointerCoords.x;\n    const vectorY: number = secondPointerCoords.y - firstPointerCoords.y;\n\n    this.anchorX = (firstPointerCoords.x + secondPointerCoords.x) / 2;\n    this.anchorY = (firstPointerCoords.y + secondPointerCoords.y) / 2;\n\n    // Angle diff should be positive when rotating in clockwise direction\n    const angle: number = -Math.atan2(vectorY, vectorX);\n\n    this.rotation = Number.isNaN(this.previousAngle)\n      ? 0\n      : this.previousAngle - angle;\n\n    this.previousAngle = angle;\n\n    if (this.rotation > Math.PI) {\n      this.rotation -= Math.PI;\n    } else if (this.rotation < -Math.PI) {\n      this.rotation += Math.PI;\n    }\n\n    if (this.rotation > Math.PI / 2) {\n      this.rotation -= Math.PI;\n    } else if (this.rotation < -Math.PI / 2) {\n      this.rotation += Math.PI;\n    }\n  }\n\n  private finish(): void {\n    if (!this.isInProgress) {\n      return;\n    }\n\n    this.isInProgress = false;\n    this.keyPointers = [NaN, NaN];\n    this.onRotationEnd(this);\n  }\n\n  private setKeyPointers(tracker: PointerTracker): void {\n    if (this.keyPointers[0] && this.keyPointers[1]) {\n      return;\n    }\n\n    const pointerIDs: IterableIterator<number> = tracker.getData().keys();\n\n    this.keyPointers[0] = pointerIDs.next().value as number;\n    this.keyPointers[1] = pointerIDs.next().value as number;\n  }\n\n  public onTouchEvent(event: AdaptedEvent, tracker: PointerTracker): boolean {\n    switch (event.eventType) {\n      case EventTypes.DOWN:\n        this.isInProgress = false;\n        break;\n\n      case EventTypes.ADDITIONAL_POINTER_DOWN:\n        if (this.isInProgress) {\n          break;\n        }\n        this.isInProgress = true;\n\n        this.previousTime = event.time;\n        this.previousAngle = NaN;\n\n        this.setKeyPointers(tracker);\n\n        this.updateCurrent(event, tracker);\n        this.onRotationBegin(this);\n        break;\n\n      case EventTypes.MOVE:\n        if (!this.isInProgress) {\n          break;\n        }\n\n        this.updateCurrent(event, tracker);\n        this.onRotation(this);\n\n        break;\n\n      case EventTypes.ADDITIONAL_POINTER_UP:\n        if (!this.isInProgress) {\n          break;\n        }\n\n        if (this.keyPointers.indexOf(event.pointerId) >= 0) {\n          this.finish();\n        }\n\n        break;\n\n      case EventTypes.UP:\n        if (this.isInProgress) {\n          this.finish();\n        }\n        break;\n    }\n\n    return true;\n  }\n\n  public getTimeDelta(): number {\n    return this.currentTime + this.previousTime;\n  }\n\n  public getAnchorX(): number {\n    return this.anchorX;\n  }\n\n  public getAnchorY(): number {\n    return this.anchorY;\n  }\n\n  public getRotation(): number {\n    return this.rotation;\n  }\n\n  public reset(): void {\n    this.keyPointers = [NaN, NaN];\n    this.isInProgress = false;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}