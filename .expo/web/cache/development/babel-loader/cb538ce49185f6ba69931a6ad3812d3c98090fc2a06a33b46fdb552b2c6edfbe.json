{"ast":null,"code":"function _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nimport * as React from 'react';\nimport Animated from \"react-native-web/dist/exports/Animated\";\nimport Dimensions from \"react-native-web/dist/exports/Dimensions\";\nimport Easing from \"react-native-web/dist/exports/Easing\";\nimport findNodeHandle from \"react-native-web/dist/exports/findNodeHandle\";\nimport I18nManager from \"react-native-web/dist/exports/I18nManager\";\nimport Keyboard from \"react-native-web/dist/exports/Keyboard\";\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport ScrollView from \"react-native-web/dist/exports/ScrollView\";\nimport StyleSheet from \"react-native-web/dist/exports/StyleSheet\";\nimport View from \"react-native-web/dist/exports/View\";\nimport Pressable from \"react-native-web/dist/exports/Pressable\";\nimport MenuItem from './MenuItem';\nimport { APPROX_STATUSBAR_HEIGHT } from '../../constants';\nimport { withInternalTheme } from '../../core/theming';\nimport { ElevationLevels } from '../../types';\nimport { addEventListener } from '../../utils/addEventListener';\nimport { BackHandler } from '../../utils/BackHandler/BackHandler';\nimport Portal from '../Portal/Portal';\nimport Surface from '../Surface';\nconst SCREEN_INDENT = 8;\nconst ANIMATION_DURATION = 250;\nconst EASING = Easing.bezier(0.4, 0, 0.2, 1);\nconst WINDOW_LAYOUT = Dimensions.get('window');\nconst DEFAULT_ELEVATION = 2;\nexport const ELEVATION_LEVELS_MAP = Object.values(ElevationLevels);\nconst DEFAULT_MODE = 'elevated';\nclass Menu extends React.Component {\n  static Item = MenuItem;\n  static defaultProps = {\n    statusBarHeight: APPROX_STATUSBAR_HEIGHT,\n    overlayAccessibilityLabel: 'Close menu',\n    testID: 'menu'\n  };\n  static getDerivedStateFromProps(nextProps, prevState) {\n    if (nextProps.visible && !prevState.rendered) {\n      return {\n        rendered: true\n      };\n    }\n    return null;\n  }\n  state = {\n    rendered: this.props.visible,\n    top: 0,\n    left: 0,\n    menuLayout: {\n      width: 0,\n      height: 0\n    },\n    anchorLayout: {\n      width: 0,\n      height: 0\n    },\n    opacityAnimation: new Animated.Value(0),\n    scaleAnimation: new Animated.ValueXY({\n      x: 0,\n      y: 0\n    }),\n    windowLayout: {\n      width: WINDOW_LAYOUT.width,\n      height: WINDOW_LAYOUT.height\n    }\n  };\n  componentDidMount() {\n    this.keyboardDidShowListener = Keyboard.addListener('keyboardDidShow', this.keyboardDidShow);\n    this.keyboardDidHideListener = Keyboard.addListener('keyboardDidHide', this.keyboardDidHide);\n  }\n  componentDidUpdate(prevProps) {\n    if (prevProps.visible !== this.props.visible) {\n      this.updateVisibility();\n    }\n  }\n  componentWillUnmount() {\n    var _this$keyboardDidShow, _this$keyboardDidHide;\n    this.removeListeners();\n    (_this$keyboardDidShow = this.keyboardDidShowListener) === null || _this$keyboardDidShow === void 0 ? void 0 : _this$keyboardDidShow.remove();\n    (_this$keyboardDidHide = this.keyboardDidHideListener) === null || _this$keyboardDidHide === void 0 ? void 0 : _this$keyboardDidHide.remove();\n  }\n  anchor = null;\n  menu = null;\n  keyboardHeight = 0;\n  isCoordinate = anchor => !React.isValidElement(anchor) && typeof (anchor === null || anchor === void 0 ? void 0 : anchor.x) === 'number' && typeof (anchor === null || anchor === void 0 ? void 0 : anchor.y) === 'number';\n  measureMenuLayout = () => new Promise(resolve => {\n    if (this.menu) {\n      this.menu.measureInWindow((x, y, width, height) => {\n        resolve({\n          x,\n          y,\n          width,\n          height\n        });\n      });\n    }\n  });\n  measureAnchorLayout = () => new Promise(resolve => {\n    const {\n      anchor\n    } = this.props;\n    if (this.isCoordinate(anchor)) {\n      resolve({\n        x: anchor.x,\n        y: anchor.y,\n        width: 0,\n        height: 0\n      });\n      return;\n    }\n    if (this.anchor) {\n      this.anchor.measureInWindow((x, y, width, height) => {\n        resolve({\n          x,\n          y,\n          width,\n          height\n        });\n      });\n    }\n  });\n  updateVisibility = async () => {\n    await Promise.resolve();\n    if (this.props.visible) {\n      this.show();\n    } else {\n      this.hide();\n    }\n  };\n  isBrowser = () => Platform.OS === 'web' && 'document' in global;\n  focusFirstDOMNode = el => {\n    if (el && this.isBrowser()) {\n      const node = findNodeHandle(el);\n      const focusableNode = node.querySelector('button, [href], input, select, textarea, [tabindex]:not([tabindex=\"-1\"])');\n      focusableNode === null || focusableNode === void 0 ? void 0 : focusableNode.focus();\n    }\n  };\n  handleDismiss = () => {\n    if (this.props.visible) {\n      var _this$props$onDismiss, _this$props;\n      (_this$props$onDismiss = (_this$props = this.props).onDismiss) === null || _this$props$onDismiss === void 0 ? void 0 : _this$props$onDismiss.call(_this$props);\n    }\n    return true;\n  };\n  handleKeypress = e => {\n    if (e.key === 'Escape') {\n      var _this$props$onDismiss2, _this$props2;\n      (_this$props$onDismiss2 = (_this$props2 = this.props).onDismiss) === null || _this$props$onDismiss2 === void 0 ? void 0 : _this$props$onDismiss2.call(_this$props2);\n    }\n  };\n  attachListeners = () => {\n    this.backHandlerSubscription = addEventListener(BackHandler, 'hardwareBackPress', this.handleDismiss);\n    this.dimensionsSubscription = addEventListener(Dimensions, 'change', this.handleDismiss);\n    this.isBrowser() && document.addEventListener('keyup', this.handleKeypress);\n  };\n  removeListeners = () => {\n    var _this$backHandlerSubs, _this$dimensionsSubsc;\n    (_this$backHandlerSubs = this.backHandlerSubscription) === null || _this$backHandlerSubs === void 0 ? void 0 : _this$backHandlerSubs.remove();\n    (_this$dimensionsSubsc = this.dimensionsSubscription) === null || _this$dimensionsSubsc === void 0 ? void 0 : _this$dimensionsSubsc.remove();\n    this.isBrowser() && document.removeEventListener('keyup', this.handleKeypress);\n  };\n  show = async () => {\n    const windowLayout = Dimensions.get('window');\n    const [menuLayout, anchorLayout] = await Promise.all([this.measureMenuLayout(), this.measureAnchorLayout()]);\n    if (!windowLayout.width || !windowLayout.height || !menuLayout.width || !menuLayout.height || !anchorLayout.width && !this.isCoordinate(this.props.anchor) || !anchorLayout.height && !this.isCoordinate(this.props.anchor)) {\n      requestAnimationFrame(this.show);\n      return;\n    }\n    this.setState(() => ({\n      left: anchorLayout.x,\n      top: anchorLayout.y,\n      anchorLayout: {\n        height: anchorLayout.height,\n        width: anchorLayout.width\n      },\n      menuLayout: {\n        width: menuLayout.width,\n        height: menuLayout.height\n      },\n      windowLayout: {\n        height: windowLayout.height - this.keyboardHeight,\n        width: windowLayout.width\n      }\n    }), () => {\n      this.attachListeners();\n      const {\n        animation\n      } = this.props.theme;\n      Animated.parallel([Animated.timing(this.state.scaleAnimation, {\n        toValue: {\n          x: menuLayout.width,\n          y: menuLayout.height\n        },\n        duration: ANIMATION_DURATION * animation.scale,\n        easing: EASING,\n        useNativeDriver: true\n      }), Animated.timing(this.state.opacityAnimation, {\n        toValue: 1,\n        duration: ANIMATION_DURATION * animation.scale,\n        easing: EASING,\n        useNativeDriver: true\n      })]).start(_ref => {\n        let {\n          finished\n        } = _ref;\n        if (finished) {\n          this.focusFirstDOMNode(this.menu);\n        }\n      });\n    });\n  };\n  hide = () => {\n    this.removeListeners();\n    const {\n      animation\n    } = this.props.theme;\n    Animated.timing(this.state.opacityAnimation, {\n      toValue: 0,\n      duration: ANIMATION_DURATION * animation.scale,\n      easing: EASING,\n      useNativeDriver: true\n    }).start(_ref2 => {\n      let {\n        finished\n      } = _ref2;\n      if (finished) {\n        this.setState({\n          menuLayout: {\n            width: 0,\n            height: 0\n          },\n          rendered: false\n        });\n        this.state.scaleAnimation.setValue({\n          x: 0,\n          y: 0\n        });\n        this.focusFirstDOMNode(this.anchor);\n      }\n    });\n  };\n  keyboardDidShow = e => {\n    const keyboardHeight = e.endCoordinates.height;\n    this.keyboardHeight = keyboardHeight;\n  };\n  keyboardDidHide = () => {\n    this.keyboardHeight = 0;\n  };\n  render() {\n    const {\n      visible,\n      anchor,\n      anchorPosition,\n      contentStyle,\n      style,\n      elevation = DEFAULT_ELEVATION,\n      mode = DEFAULT_MODE,\n      children,\n      theme,\n      statusBarHeight,\n      onDismiss,\n      overlayAccessibilityLabel,\n      keyboardShouldPersistTaps,\n      testID\n    } = this.props;\n    const {\n      rendered,\n      menuLayout,\n      anchorLayout,\n      opacityAnimation,\n      scaleAnimation,\n      windowLayout\n    } = this.state;\n    let {\n      left,\n      top\n    } = this.state;\n    if (!this.isCoordinate(this.anchor) && anchorPosition === 'bottom') {\n      top += anchorLayout.height;\n    }\n    const additionalVerticalValue = Platform.select({\n      android: statusBarHeight,\n      default: 0\n    });\n    const scaleTransforms = [{\n      scaleX: scaleAnimation.x.interpolate({\n        inputRange: [0, menuLayout.width],\n        outputRange: [0, 1]\n      })\n    }, {\n      scaleY: scaleAnimation.y.interpolate({\n        inputRange: [0, menuLayout.height],\n        outputRange: [0, 1]\n      })\n    }];\n    const positionTransforms = [];\n    if (left <= windowLayout.width - menuLayout.width - SCREEN_INDENT) {\n      positionTransforms.push({\n        translateX: scaleAnimation.x.interpolate({\n          inputRange: [0, menuLayout.width],\n          outputRange: [-(menuLayout.width / 2), 0]\n        })\n      });\n      if (left < SCREEN_INDENT) {\n        left = SCREEN_INDENT;\n      }\n    } else {\n      positionTransforms.push({\n        translateX: scaleAnimation.x.interpolate({\n          inputRange: [0, menuLayout.width],\n          outputRange: [menuLayout.width / 2, 0]\n        })\n      });\n      left += anchorLayout.width - menuLayout.width;\n      const right = left + menuLayout.width;\n      if (right > windowLayout.width - SCREEN_INDENT) {\n        left = windowLayout.width - SCREEN_INDENT - menuLayout.width;\n      }\n    }\n    let scrollableMenuHeight = 0;\n    if (top >= windowLayout.height - menuLayout.height - SCREEN_INDENT - additionalVerticalValue && top <= windowLayout.height - top) {\n      scrollableMenuHeight = windowLayout.height - top - SCREEN_INDENT - additionalVerticalValue;\n    } else if (top >= windowLayout.height - menuLayout.height - SCREEN_INDENT - additionalVerticalValue && top >= windowLayout.height - top && top <= menuLayout.height - anchorLayout.height + SCREEN_INDENT - additionalVerticalValue) {\n      scrollableMenuHeight = top + anchorLayout.height - SCREEN_INDENT + additionalVerticalValue;\n    }\n    scrollableMenuHeight = scrollableMenuHeight > windowLayout.height - 2 * SCREEN_INDENT ? windowLayout.height - 2 * SCREEN_INDENT : scrollableMenuHeight;\n    if (top <= windowLayout.height - menuLayout.height - SCREEN_INDENT - additionalVerticalValue || top >= windowLayout.height - menuLayout.height - SCREEN_INDENT - additionalVerticalValue && top <= windowLayout.height - top) {\n      positionTransforms.push({\n        translateY: scaleAnimation.y.interpolate({\n          inputRange: [0, menuLayout.height],\n          outputRange: [-((scrollableMenuHeight || menuLayout.height) / 2), 0]\n        })\n      });\n      if (top < SCREEN_INDENT) {\n        top = SCREEN_INDENT;\n      }\n    } else {\n      positionTransforms.push({\n        translateY: scaleAnimation.y.interpolate({\n          inputRange: [0, menuLayout.height],\n          outputRange: [(scrollableMenuHeight || menuLayout.height) / 2, 0]\n        })\n      });\n      top += anchorLayout.height - (scrollableMenuHeight || menuLayout.height);\n      const bottom = top + (scrollableMenuHeight || menuLayout.height) + additionalVerticalValue;\n      if (bottom > windowLayout.height - SCREEN_INDENT) {\n        top = scrollableMenuHeight === windowLayout.height - 2 * SCREEN_INDENT ? -SCREEN_INDENT * 2 : windowLayout.height - menuLayout.height - SCREEN_INDENT - additionalVerticalValue;\n      }\n    }\n    const shadowMenuContainerStyle = Object.assign({\n      opacity: opacityAnimation,\n      transform: scaleTransforms,\n      borderRadius: theme.roundness\n    }, !theme.isV3 && {\n      elevation: 8\n    }, scrollableMenuHeight ? {\n      height: scrollableMenuHeight\n    } : {});\n    const positionStyle = Object.assign({\n      top: this.isCoordinate(anchor) ? top : top + additionalVerticalValue\n    }, I18nManager.getConstants().isRTL ? {\n      right: left\n    } : {\n      left\n    });\n    const pointerEvents = visible ? 'box-none' : 'none';\n    return React.createElement(View, {\n      ref: ref => {\n        this.anchor = ref;\n      },\n      collapsable: false\n    }, this.isCoordinate(anchor) ? null : anchor, rendered ? React.createElement(Portal, null, React.createElement(Pressable, {\n      accessibilityLabel: overlayAccessibilityLabel,\n      accessibilityRole: \"button\",\n      onPress: onDismiss,\n      style: styles.pressableOverlay\n    }), React.createElement(View, {\n      ref: ref => {\n        this.menu = ref;\n      },\n      collapsable: false,\n      accessibilityViewIsModal: visible,\n      style: [styles.wrapper, positionStyle, style],\n      pointerEvents: pointerEvents,\n      onAccessibilityEscape: onDismiss,\n      testID: `${testID}-view`\n    }, React.createElement(Animated.View, {\n      pointerEvents: pointerEvents,\n      style: {\n        transform: positionTransforms\n      }\n    }, React.createElement(Surface, _extends({\n      mode: mode,\n      pointerEvents: pointerEvents,\n      style: [styles.shadowMenuContainer, shadowMenuContainerStyle, theme.isV3 && {\n        backgroundColor: theme.colors.elevation[ELEVATION_LEVELS_MAP[elevation]]\n      }, contentStyle]\n    }, theme.isV3 && {\n      elevation\n    }, {\n      testID: `${testID}-surface`,\n      theme: theme\n    }), scrollableMenuHeight && React.createElement(ScrollView, {\n      keyboardShouldPersistTaps: keyboardShouldPersistTaps\n    }, children) || React.createElement(React.Fragment, null, children))))) : null);\n  }\n}\nconst styles = StyleSheet.create({\n  wrapper: {\n    position: 'absolute'\n  },\n  shadowMenuContainer: {\n    opacity: 0,\n    paddingVertical: 8\n  },\n  pressableOverlay: Object.assign({}, StyleSheet.absoluteFillObject, Platform.OS === 'web' && {\n    cursor: 'default'\n  }, {\n    width: '100%'\n  })\n});\nexport default withInternalTheme(Menu);","map":{"version":3,"names":["React","Animated","Dimensions","Easing","findNodeHandle","I18nManager","Keyboard","Platform","ScrollView","StyleSheet","View","Pressable","MenuItem","APPROX_STATUSBAR_HEIGHT","withInternalTheme","ElevationLevels","addEventListener","BackHandler","Portal","Surface","SCREEN_INDENT","ANIMATION_DURATION","EASING","bezier","WINDOW_LAYOUT","get","DEFAULT_ELEVATION","ELEVATION_LEVELS_MAP","Object","values","DEFAULT_MODE","Menu","Component","Item","defaultProps","statusBarHeight","overlayAccessibilityLabel","testID","getDerivedStateFromProps","nextProps","prevState","visible","rendered","state","props","top","left","menuLayout","width","height","anchorLayout","opacityAnimation","Value","scaleAnimation","ValueXY","x","y","windowLayout","componentDidMount","keyboardDidShowListener","addListener","keyboardDidShow","keyboardDidHideListener","keyboardDidHide","componentDidUpdate","prevProps","updateVisibility","componentWillUnmount","_this$keyboardDidShow","_this$keyboardDidHide","removeListeners","remove","anchor","menu","keyboardHeight","isCoordinate","isValidElement","measureMenuLayout","Promise","resolve","measureInWindow","measureAnchorLayout","show","hide","isBrowser","OS","global","focusFirstDOMNode","el","node","focusableNode","querySelector","focus","handleDismiss","_this$props$onDismiss","_this$props","onDismiss","call","handleKeypress","e","key","_this$props$onDismiss2","_this$props2","attachListeners","backHandlerSubscription","dimensionsSubscription","document","_this$backHandlerSubs","_this$dimensionsSubsc","removeEventListener","all","requestAnimationFrame","setState","animation","theme","parallel","timing","toValue","duration","scale","easing","useNativeDriver","start","_ref","finished","_ref2","setValue","endCoordinates","render","anchorPosition","contentStyle","style","elevation","mode","children","keyboardShouldPersistTaps","additionalVerticalValue","select","android","default","scaleTransforms","scaleX","interpolate","inputRange","outputRange","scaleY","positionTransforms","push","translateX","right","scrollableMenuHeight","translateY","bottom","shadowMenuContainerStyle","assign","opacity","transform","borderRadius","roundness","isV3","positionStyle","getConstants","isRTL","pointerEvents","createElement","ref","collapsable","accessibilityLabel","accessibilityRole","onPress","styles","pressableOverlay","accessibilityViewIsModal","wrapper","onAccessibilityEscape","_extends","shadowMenuContainer","backgroundColor","colors","Fragment","create","position","paddingVertical","absoluteFillObject","cursor"],"sources":["C:\\Users\\user\\OneDrive\\Documents\\rn\\l\\node_modules\\react-native-paper\\src\\components\\Menu\\Menu.tsx"],"sourcesContent":["import * as React from 'react';\nimport {\n  Animated,\n  Dimensions,\n  Easing,\n  EmitterSubscription,\n  findNodeHandle,\n  I18nManager,\n  Keyboard,\n  KeyboardEvent as RNKeyboardEvent,\n  LayoutRectangle,\n  NativeEventSubscription,\n  Platform,\n  ScrollView,\n  ScrollViewProps,\n  StyleProp,\n  StyleSheet,\n  View,\n  ViewStyle,\n  Pressable,\n} from 'react-native';\n\nimport MenuItem from './MenuItem';\nimport { APPROX_STATUSBAR_HEIGHT } from '../../constants';\nimport { withInternalTheme } from '../../core/theming';\nimport type { $Omit, InternalTheme, MD3Elevation } from '../../types';\nimport { ElevationLevels } from '../../types';\nimport { addEventListener } from '../../utils/addEventListener';\nimport { BackHandler } from '../../utils/BackHandler/BackHandler';\nimport Portal from '../Portal/Portal';\nimport Surface from '../Surface';\n\nexport type Props = {\n  /**\n   * Whether the Menu is currently visible.\n   */\n  visible: boolean;\n  /**\n   * The anchor to open the menu from. In most cases, it will be a button that opens the menu.\n   */\n  anchor: React.ReactNode | { x: number; y: number };\n  /**\n   * Whether the menu should open at the top of the anchor or at its bottom.\n   * Applied only when anchor is a node, not an x/y position.\n   */\n  anchorPosition?: 'top' | 'bottom';\n  /**\n   * Extra margin to add at the top of the menu to account for translucent status bar on Android.\n   * If you are using Expo, we assume translucent status bar and set a height for status bar automatically.\n   * Pass `0` or a custom value to and customize it.\n   * This is automatically handled on iOS.\n   */\n  statusBarHeight?: number;\n  /**\n   * Callback called when Menu is dismissed. The `visible` prop needs to be updated when this is called.\n   */\n  onDismiss?: () => void;\n  /**\n   * Accessibility label for the overlay. This is read by the screen reader when the user taps outside the menu.\n   */\n  overlayAccessibilityLabel?: string;\n  /**\n   * Content of the `Menu`.\n   */\n  children: React.ReactNode;\n  /**\n   * Style of menu's inner content.\n   */\n  contentStyle?: Animated.WithAnimatedValue<StyleProp<ViewStyle>>;\n  style?: StyleProp<ViewStyle>;\n  /**\n   * Elevation level of the menu's content. Shadow styles are calculated based on this value. Default `backgroundColor` is taken from the corresponding `theme.colors.elevation` property. By default equals `2`.\n   * @supported Available in v5.x with theme version 3\n   */\n  elevation?: MD3Elevation;\n  /**\n   * Mode of the menu's content.\n   * - `elevated` - Surface with a shadow and background color corresponding to set `elevation` value.\n   * - `flat` - Surface without a shadow, with the background color corresponding to set `elevation` value.\n   *\n   * @supported Available in v5.x with theme version 3\n   */\n  mode?: 'flat' | 'elevated';\n  /**\n   * @optional\n   */\n  theme: InternalTheme;\n  /**\n   * Inner ScrollView prop\n   */\n  keyboardShouldPersistTaps?: ScrollViewProps['keyboardShouldPersistTaps'];\n  /**\n   * testID to be used on tests.\n   */\n  testID?: string;\n};\n\ntype Layout = $Omit<$Omit<LayoutRectangle, 'x'>, 'y'>;\n\ntype State = {\n  rendered: boolean;\n  top: number;\n  left: number;\n  menuLayout: Layout;\n  anchorLayout: Layout;\n  opacityAnimation: Animated.Value;\n  scaleAnimation: Animated.ValueXY;\n  windowLayout: Layout;\n};\n\n// Minimum padding between the edge of the screen and the menu\nconst SCREEN_INDENT = 8;\n// From https://material.io/design/motion/speed.html#duration\nconst ANIMATION_DURATION = 250;\n// From the 'Standard easing' section of https://material.io/design/motion/speed.html#easing\nconst EASING = Easing.bezier(0.4, 0, 0.2, 1);\n\nconst WINDOW_LAYOUT = Dimensions.get('window');\n\nconst DEFAULT_ELEVATION: MD3Elevation = 2;\nexport const ELEVATION_LEVELS_MAP = Object.values(\n  ElevationLevels\n) as ElevationLevels[];\n\nconst DEFAULT_MODE = 'elevated';\n\n/**\n * Menus display a list of choices on temporary elevated surfaces. Their placement varies based on the element that opens them.\n *\n * ## Usage\n * ```js\n * import * as React from 'react';\n * import { View } from 'react-native';\n * import { Button, Menu, Divider, PaperProvider } from 'react-native-paper';\n *\n * const MyComponent = () => {\n *   const [visible, setVisible] = React.useState(false);\n *\n *   const openMenu = () => setVisible(true);\n *\n *   const closeMenu = () => setVisible(false);\n *\n *   return (\n *     <PaperProvider>\n *       <View\n *         style={{\n *           paddingTop: 50,\n *           flexDirection: 'row',\n *           justifyContent: 'center',\n *         }}>\n *         <Menu\n *           visible={visible}\n *           onDismiss={closeMenu}\n *           anchor={<Button onPress={openMenu}>Show menu</Button>}>\n *           <Menu.Item onPress={() => {}} title=\"Item 1\" />\n *           <Menu.Item onPress={() => {}} title=\"Item 2\" />\n *           <Divider />\n *           <Menu.Item onPress={() => {}} title=\"Item 3\" />\n *         </Menu>\n *       </View>\n *     </PaperProvider>\n *   );\n * };\n *\n * export default MyComponent;\n * ```\n *\n * ### Note\n * When using `Menu` within a React Native's `Modal` component, you need to wrap all\n * `Modal` contents within a `PaperProvider` in order for the menu to show. This\n * wrapping is not necessary if you use Paper's `Modal` instead.\n */\nclass Menu extends React.Component<Props, State> {\n  // @component ./MenuItem.tsx\n  static Item = MenuItem;\n\n  static defaultProps = {\n    statusBarHeight: APPROX_STATUSBAR_HEIGHT,\n    overlayAccessibilityLabel: 'Close menu',\n    testID: 'menu',\n  };\n\n  static getDerivedStateFromProps(nextProps: Props, prevState: State) {\n    if (nextProps.visible && !prevState.rendered) {\n      return { rendered: true };\n    }\n\n    return null;\n  }\n\n  state = {\n    rendered: this.props.visible,\n    top: 0,\n    left: 0,\n    menuLayout: { width: 0, height: 0 },\n    anchorLayout: { width: 0, height: 0 },\n    opacityAnimation: new Animated.Value(0),\n    scaleAnimation: new Animated.ValueXY({ x: 0, y: 0 }),\n    windowLayout: {\n      width: WINDOW_LAYOUT.width,\n      height: WINDOW_LAYOUT.height,\n    },\n  };\n\n  componentDidMount() {\n    this.keyboardDidShowListener = Keyboard.addListener(\n      'keyboardDidShow',\n      this.keyboardDidShow\n    );\n    this.keyboardDidHideListener = Keyboard.addListener(\n      'keyboardDidHide',\n      this.keyboardDidHide\n    );\n  }\n\n  componentDidUpdate(prevProps: Props) {\n    if (prevProps.visible !== this.props.visible) {\n      this.updateVisibility();\n    }\n  }\n\n  componentWillUnmount() {\n    this.removeListeners();\n    this.keyboardDidShowListener?.remove();\n    this.keyboardDidHideListener?.remove();\n  }\n\n  private anchor?: View | null = null;\n  private menu?: View | null = null;\n  private backHandlerSubscription: NativeEventSubscription | undefined;\n  private dimensionsSubscription: NativeEventSubscription | undefined;\n  private keyboardDidShowListener: EmitterSubscription | undefined;\n  private keyboardDidHideListener: EmitterSubscription | undefined;\n  private keyboardHeight: number = 0;\n\n  private isCoordinate = (anchor: any): anchor is { x: number; y: number } =>\n    !React.isValidElement(anchor) &&\n    typeof anchor?.x === 'number' &&\n    typeof anchor?.y === 'number';\n\n  private measureMenuLayout = () =>\n    new Promise<LayoutRectangle>((resolve) => {\n      if (this.menu) {\n        this.menu.measureInWindow((x, y, width, height) => {\n          resolve({ x, y, width, height });\n        });\n      }\n    });\n\n  private measureAnchorLayout = () =>\n    new Promise<LayoutRectangle>((resolve) => {\n      const { anchor } = this.props;\n      if (this.isCoordinate(anchor)) {\n        resolve({ x: anchor.x, y: anchor.y, width: 0, height: 0 });\n        return;\n      }\n\n      if (this.anchor) {\n        this.anchor.measureInWindow((x, y, width, height) => {\n          resolve({ x, y, width, height });\n        });\n      }\n    });\n\n  private updateVisibility = async () => {\n    // Menu is rendered in Portal, which updates items asynchronously\n    // We need to do the same here so that the ref is up-to-date\n    await Promise.resolve();\n\n    if (this.props.visible) {\n      this.show();\n    } else {\n      this.hide();\n    }\n  };\n\n  private isBrowser = () => Platform.OS === 'web' && 'document' in global;\n\n  private focusFirstDOMNode = (el: View | null | undefined) => {\n    if (el && this.isBrowser()) {\n      // When in the browser, we want to focus the first focusable item on toggle\n      // For example, when menu is shown, focus the first item in the menu\n      // And when menu is dismissed, send focus back to the button to resume tabbing\n      const node: any = findNodeHandle(el);\n      const focusableNode = node.querySelector(\n        // This is a rough list of selectors that can be focused\n        'button, [href], input, select, textarea, [tabindex]:not([tabindex=\"-1\"])'\n      );\n\n      focusableNode?.focus();\n    }\n  };\n\n  private handleDismiss = () => {\n    if (this.props.visible) {\n      this.props.onDismiss?.();\n    }\n    return true;\n  };\n\n  private handleKeypress = (e: KeyboardEvent) => {\n    if (e.key === 'Escape') {\n      this.props.onDismiss?.();\n    }\n  };\n\n  private attachListeners = () => {\n    this.backHandlerSubscription = addEventListener(\n      BackHandler,\n      'hardwareBackPress',\n      this.handleDismiss\n    );\n    this.dimensionsSubscription = addEventListener(\n      Dimensions,\n      'change',\n      this.handleDismiss\n    );\n    this.isBrowser() && document.addEventListener('keyup', this.handleKeypress);\n  };\n\n  private removeListeners = () => {\n    this.backHandlerSubscription?.remove();\n    this.dimensionsSubscription?.remove();\n    this.isBrowser() &&\n      document.removeEventListener('keyup', this.handleKeypress);\n  };\n\n  private show = async () => {\n    const windowLayout = Dimensions.get('window');\n    const [menuLayout, anchorLayout] = await Promise.all([\n      this.measureMenuLayout(),\n      this.measureAnchorLayout(),\n    ]);\n\n    // When visible is true for first render\n    // native views can be still not rendered and\n    // measureMenuLayout/measureAnchorLayout functions\n    // return wrong values e.g { x:0, y: 0, width: 0, height: 0 }\n    // so we have to wait until views are ready\n    // and rerun this function to show menu\n    if (\n      !windowLayout.width ||\n      !windowLayout.height ||\n      !menuLayout.width ||\n      !menuLayout.height ||\n      (!anchorLayout.width && !this.isCoordinate(this.props.anchor)) ||\n      (!anchorLayout.height && !this.isCoordinate(this.props.anchor))\n    ) {\n      requestAnimationFrame(this.show);\n      return;\n    }\n\n    this.setState(\n      () => ({\n        left: anchorLayout.x,\n        top: anchorLayout.y,\n        anchorLayout: {\n          height: anchorLayout.height,\n          width: anchorLayout.width,\n        },\n        menuLayout: {\n          width: menuLayout.width,\n          height: menuLayout.height,\n        },\n        windowLayout: {\n          height: windowLayout.height - this.keyboardHeight,\n          width: windowLayout.width,\n        },\n      }),\n      () => {\n        this.attachListeners();\n\n        const { animation } = this.props.theme;\n        Animated.parallel([\n          Animated.timing(this.state.scaleAnimation, {\n            toValue: { x: menuLayout.width, y: menuLayout.height },\n            duration: ANIMATION_DURATION * animation.scale,\n            easing: EASING,\n            useNativeDriver: true,\n          }),\n          Animated.timing(this.state.opacityAnimation, {\n            toValue: 1,\n            duration: ANIMATION_DURATION * animation.scale,\n            easing: EASING,\n            useNativeDriver: true,\n          }),\n        ]).start(({ finished }) => {\n          if (finished) {\n            this.focusFirstDOMNode(this.menu);\n          }\n        });\n      }\n    );\n  };\n\n  private hide = () => {\n    this.removeListeners();\n\n    const { animation } = this.props.theme;\n    Animated.timing(this.state.opacityAnimation, {\n      toValue: 0,\n      duration: ANIMATION_DURATION * animation.scale,\n      easing: EASING,\n      useNativeDriver: true,\n    }).start(({ finished }) => {\n      if (finished) {\n        this.setState({ menuLayout: { width: 0, height: 0 }, rendered: false });\n        this.state.scaleAnimation.setValue({ x: 0, y: 0 });\n        this.focusFirstDOMNode(this.anchor);\n      }\n    });\n  };\n\n  private keyboardDidShow = (e: RNKeyboardEvent) => {\n    const keyboardHeight = e.endCoordinates.height;\n    this.keyboardHeight = keyboardHeight;\n  };\n\n  private keyboardDidHide = () => {\n    this.keyboardHeight = 0;\n  };\n\n  render() {\n    const {\n      visible,\n      anchor,\n      anchorPosition,\n      contentStyle,\n      style,\n      elevation = DEFAULT_ELEVATION,\n      mode = DEFAULT_MODE,\n      children,\n      theme,\n      statusBarHeight,\n      onDismiss,\n      overlayAccessibilityLabel,\n      keyboardShouldPersistTaps,\n      testID,\n    } = this.props;\n\n    const {\n      rendered,\n      menuLayout,\n      anchorLayout,\n      opacityAnimation,\n      scaleAnimation,\n      windowLayout,\n    } = this.state;\n\n    let { left, top } = this.state;\n\n    if (!this.isCoordinate(this.anchor) && anchorPosition === 'bottom') {\n      top += anchorLayout.height;\n    }\n\n    // I don't know why but on Android measure function is wrong by 24\n    const additionalVerticalValue = Platform.select({\n      android: statusBarHeight,\n      default: 0,\n    });\n\n    const scaleTransforms = [\n      {\n        scaleX: scaleAnimation.x.interpolate({\n          inputRange: [0, menuLayout.width],\n          outputRange: [0, 1],\n        }),\n      },\n      {\n        scaleY: scaleAnimation.y.interpolate({\n          inputRange: [0, menuLayout.height],\n          outputRange: [0, 1],\n        }),\n      },\n    ];\n\n    // We need to translate menu while animating scale to imitate transform origin for scale animation\n    const positionTransforms = [];\n\n    // Check if menu fits horizontally and if not align it to right.\n    if (left <= windowLayout.width - menuLayout.width - SCREEN_INDENT) {\n      positionTransforms.push({\n        translateX: scaleAnimation.x.interpolate({\n          inputRange: [0, menuLayout.width],\n          outputRange: [-(menuLayout.width / 2), 0],\n        }),\n      });\n\n      // Check if menu position has enough space from left side\n      if (left < SCREEN_INDENT) {\n        left = SCREEN_INDENT;\n      }\n    } else {\n      positionTransforms.push({\n        translateX: scaleAnimation.x.interpolate({\n          inputRange: [0, menuLayout.width],\n          outputRange: [menuLayout.width / 2, 0],\n        }),\n      });\n\n      left += anchorLayout.width - menuLayout.width;\n\n      const right = left + menuLayout.width;\n      // Check if menu position has enough space from right side\n      if (right > windowLayout.width - SCREEN_INDENT) {\n        left = windowLayout.width - SCREEN_INDENT - menuLayout.width;\n      }\n    }\n\n    // If the menu is larger than available vertical space,\n    // calculate the height of scrollable view\n    let scrollableMenuHeight = 0;\n\n    // Check if the menu should be scrollable\n    if (\n      // Check if the menu overflows from bottom side\n      top >=\n        windowLayout.height -\n          menuLayout.height -\n          SCREEN_INDENT -\n          additionalVerticalValue &&\n      // And bottom side of the screen has more space than top side\n      top <= windowLayout.height - top\n    ) {\n      // Scrollable menu should be below the anchor (expands downwards)\n      scrollableMenuHeight =\n        windowLayout.height - top - SCREEN_INDENT - additionalVerticalValue;\n    } else if (\n      // Check if the menu overflows from bottom side\n      top >=\n        windowLayout.height -\n          menuLayout.height -\n          SCREEN_INDENT -\n          additionalVerticalValue &&\n      // And top side of the screen has more space than bottom side\n      top >= windowLayout.height - top &&\n      // And menu overflows from top side\n      top <=\n        menuLayout.height -\n          anchorLayout.height +\n          SCREEN_INDENT -\n          additionalVerticalValue\n    ) {\n      // Scrollable menu should be above the anchor (expands upwards)\n      scrollableMenuHeight =\n        top + anchorLayout.height - SCREEN_INDENT + additionalVerticalValue;\n    }\n\n    // Scrollable menu max height\n    scrollableMenuHeight =\n      scrollableMenuHeight > windowLayout.height - 2 * SCREEN_INDENT\n        ? windowLayout.height - 2 * SCREEN_INDENT\n        : scrollableMenuHeight;\n\n    // Menu is typically positioned below the element that generates it\n    // So first check if it fits below the anchor (expands downwards)\n    if (\n      // Check if menu fits vertically\n      top <=\n        windowLayout.height -\n          menuLayout.height -\n          SCREEN_INDENT -\n          additionalVerticalValue ||\n      // Or if the menu overflows from bottom side\n      (top >=\n        windowLayout.height -\n          menuLayout.height -\n          SCREEN_INDENT -\n          additionalVerticalValue &&\n        // And bottom side of the screen has more space than top side\n        top <= windowLayout.height - top)\n    ) {\n      positionTransforms.push({\n        translateY: scaleAnimation.y.interpolate({\n          inputRange: [0, menuLayout.height],\n          outputRange: [-((scrollableMenuHeight || menuLayout.height) / 2), 0],\n        }),\n      });\n\n      // Check if menu position has enough space from top side\n      if (top < SCREEN_INDENT) {\n        top = SCREEN_INDENT;\n      }\n    } else {\n      positionTransforms.push({\n        translateY: scaleAnimation.y.interpolate({\n          inputRange: [0, menuLayout.height],\n          outputRange: [(scrollableMenuHeight || menuLayout.height) / 2, 0],\n        }),\n      });\n\n      top += anchorLayout.height - (scrollableMenuHeight || menuLayout.height);\n\n      const bottom =\n        top +\n        (scrollableMenuHeight || menuLayout.height) +\n        additionalVerticalValue;\n\n      // Check if menu position has enough space from bottom side\n      if (bottom > windowLayout.height - SCREEN_INDENT) {\n        top =\n          scrollableMenuHeight === windowLayout.height - 2 * SCREEN_INDENT\n            ? -SCREEN_INDENT * 2\n            : windowLayout.height -\n              menuLayout.height -\n              SCREEN_INDENT -\n              additionalVerticalValue;\n      }\n    }\n\n    const shadowMenuContainerStyle = {\n      opacity: opacityAnimation,\n      transform: scaleTransforms,\n      borderRadius: theme.roundness,\n      ...(!theme.isV3 && { elevation: 8 }),\n      ...(scrollableMenuHeight ? { height: scrollableMenuHeight } : {}),\n    };\n\n    const positionStyle = {\n      top: this.isCoordinate(anchor) ? top : top + additionalVerticalValue,\n      ...(I18nManager.getConstants().isRTL ? { right: left } : { left }),\n    };\n\n    const pointerEvents = visible ? 'box-none' : 'none';\n\n    return (\n      <View\n        ref={(ref) => {\n          this.anchor = ref;\n        }}\n        collapsable={false}\n      >\n        {this.isCoordinate(anchor) ? null : anchor}\n        {rendered ? (\n          <Portal>\n            <Pressable\n              accessibilityLabel={overlayAccessibilityLabel}\n              accessibilityRole=\"button\"\n              onPress={onDismiss}\n              style={styles.pressableOverlay}\n            />\n            <View\n              ref={(ref) => {\n                this.menu = ref;\n              }}\n              collapsable={false}\n              accessibilityViewIsModal={visible}\n              style={[styles.wrapper, positionStyle, style]}\n              pointerEvents={pointerEvents}\n              onAccessibilityEscape={onDismiss}\n              testID={`${testID}-view`}\n            >\n              <Animated.View\n                pointerEvents={pointerEvents}\n                style={{\n                  transform: positionTransforms,\n                }}\n              >\n                <Surface\n                  mode={mode}\n                  pointerEvents={pointerEvents}\n                  style={[\n                    styles.shadowMenuContainer,\n                    shadowMenuContainerStyle,\n                    theme.isV3 && {\n                      backgroundColor:\n                        theme.colors.elevation[ELEVATION_LEVELS_MAP[elevation]],\n                    },\n                    contentStyle,\n                  ]}\n                  {...(theme.isV3 && { elevation })}\n                  testID={`${testID}-surface`}\n                  theme={theme}\n                >\n                  {(scrollableMenuHeight && (\n                    <ScrollView\n                      keyboardShouldPersistTaps={keyboardShouldPersistTaps}\n                    >\n                      {children}\n                    </ScrollView>\n                  )) || <React.Fragment>{children}</React.Fragment>}\n                </Surface>\n              </Animated.View>\n            </View>\n          </Portal>\n        ) : null}\n      </View>\n    );\n  }\n}\n\nconst styles = StyleSheet.create({\n  wrapper: {\n    position: 'absolute',\n  },\n  shadowMenuContainer: {\n    opacity: 0,\n    paddingVertical: 8,\n  },\n  pressableOverlay: {\n    ...StyleSheet.absoluteFillObject,\n    ...(Platform.OS === 'web' && {\n      cursor: 'default',\n    }),\n    width: '100%',\n  },\n});\n\nexport default withInternalTheme(Menu);\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}