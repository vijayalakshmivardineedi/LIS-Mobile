{"ast":null,"code":"class TextExtraction {\n  constructor(text, patterns) {\n    this.text = text;\n    this.patterns = patterns || [];\n  }\n  parse() {\n    let parsedTexts = [{\n      children: this.text\n    }];\n    this.patterns.forEach(pattern => {\n      let newParts = [];\n      const tmp = pattern.nonExhaustiveModeMaxMatchCount || 0;\n      const numberOfMatchesPermitted = Math.min(Math.max(Number.isInteger(tmp) ? tmp : 0, 0) || Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY);\n      let currentMatches = 0;\n      parsedTexts.forEach(parsedText => {\n        if (parsedText._matched) {\n          newParts.push(parsedText);\n          return;\n        }\n        let parts = [];\n        let textLeft = parsedText.children;\n        let indexOfMatchedString = 0;\n        let matches;\n        pattern.pattern.lastIndex = 0;\n        while (textLeft && (matches = pattern.pattern.exec(textLeft))) {\n          let previousText = textLeft.substr(0, matches.index);\n          indexOfMatchedString = matches.index;\n          if (++currentMatches > numberOfMatchesPermitted) {\n            break;\n          }\n          parts.push({\n            children: previousText\n          });\n          parts.push(this.getMatchedPart(pattern, matches[0], matches, indexOfMatchedString));\n          textLeft = textLeft.substr(matches.index + matches[0].length);\n          indexOfMatchedString += matches[0].length - 1;\n          pattern.pattern.lastIndex = 0;\n        }\n        parts.push({\n          children: textLeft\n        });\n        newParts.push(...parts);\n      });\n      parsedTexts = newParts;\n    });\n    parsedTexts.forEach(parsedText => delete parsedText._matched);\n    return parsedTexts.filter(t => !!t.children);\n  }\n  getMatchedPart(matchedPattern, text, matches, index) {\n    let props = {};\n    Object.keys(matchedPattern).forEach(key => {\n      if (key === 'pattern' || key === 'renderText' || key === 'nonExhaustiveModeMaxMatchCount') {\n        return;\n      }\n      if (typeof matchedPattern[key] === 'function') {\n        props[key] = () => matchedPattern[key](text, index);\n      } else {\n        props[key] = matchedPattern[key];\n      }\n    });\n    let children = text;\n    if (matchedPattern.renderText && typeof matchedPattern.renderText === 'function') {\n      children = matchedPattern.renderText(text, matches);\n    }\n    return Object.assign({}, props, {\n      children: children,\n      _matched: true\n    });\n  }\n}\nexport default TextExtraction;","map":{"version":3,"names":["TextExtraction","constructor","text","patterns","parse","parsedTexts","children","forEach","pattern","newParts","tmp","nonExhaustiveModeMaxMatchCount","numberOfMatchesPermitted","Math","min","max","Number","isInteger","POSITIVE_INFINITY","currentMatches","parsedText","_matched","push","parts","textLeft","indexOfMatchedString","matches","lastIndex","exec","previousText","substr","index","getMatchedPart","length","filter","t","matchedPattern","props","Object","keys","key","renderText","assign"],"sources":["C:/Users/user/OneDrive/Documents/rn/l/node_modules/react-native-parsed-text/src/lib/TextExtraction.js"],"sourcesContent":["/**\n * If you want to provide a custom regexp, this is the configuration to use.\n * -- For historical reasons, all regexps are processed as if they have the global flag set.\n * -- Use the nonExhaustiveModeMaxMatchCount property to match a limited number of matches.\n * Note: any additional keys/props are permitted, and will be returned as-is!\n * @typedef {Object} CustomParseShape\n * @property {RegExp} pattern\n * @property {number} [nonExhaustiveModeMaxMatchCount] Enables \"non-exhaustive mode\", where you can limit how many matches are found. -- Must be a positive integer or Infinity matches are permitted\n * @property {Function} [renderText] arbitrary function to rewrite the matched string into something else\n * @property {Function} [onPress]\n * @property {Function} [onLongPress]\n */\n/**\n * Class to encapsulate the business logic of converting text into matches & props\n */\nclass TextExtraction {\n  /**\n   * @param {String} text - Text to be parsed\n   * @param {CustomParseShape[]} patterns - Patterns to be used when parsed,\n   *                                 any extra attributes, will be returned from parse()\n   */\n  constructor(text, patterns) {\n    this.text = text;\n    this.patterns = patterns || [];\n  }\n\n  /**\n   * Returns parts of the text with their own props\n   * @public\n   * @return {Object[]} - props for all the parts of the text\n   */\n  parse() {\n    let parsedTexts = [{ children: this.text }];\n    this.patterns.forEach((pattern) => {\n      let newParts = [];\n\n      const tmp = pattern.nonExhaustiveModeMaxMatchCount || 0;\n      const numberOfMatchesPermitted = Math.min(\n        Math.max(Number.isInteger(tmp) ? tmp : 0, 0) ||\n          Number.POSITIVE_INFINITY,\n        Number.POSITIVE_INFINITY,\n      );\n\n      let currentMatches = 0;\n\n      parsedTexts.forEach((parsedText) => {\n        // Only allow for now one parsing\n        if (parsedText._matched) {\n          newParts.push(parsedText);\n          return;\n        }\n\n        let parts = [];\n        let textLeft = parsedText.children;\n        let indexOfMatchedString = 0;\n\n        /** @type {RegExpExecArray} */\n        let matches;\n        // Global RegExps are stateful, this makes it start at 0 if reused\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec\n        pattern.pattern.lastIndex = 0;\n        while (textLeft && (matches = pattern.pattern.exec(textLeft))) {\n          let previousText = textLeft.substr(0, matches.index);\n          indexOfMatchedString = matches.index;\n\n          if (++currentMatches > numberOfMatchesPermitted) {\n            // Abort if we've exhausted our number of matches\n            break;\n          }\n\n          parts.push({ children: previousText });\n\n          parts.push(\n            this.getMatchedPart(\n              pattern,\n              matches[0],\n              matches,\n              indexOfMatchedString,\n            ),\n          );\n\n          textLeft = textLeft.substr(matches.index + matches[0].length);\n          indexOfMatchedString += matches[0].length - 1;\n          // Global RegExps are stateful, this makes it operate on the \"remainder\" of the string\n          pattern.pattern.lastIndex = 0;\n        }\n\n        parts.push({ children: textLeft });\n\n        newParts.push(...parts);\n      });\n\n      parsedTexts = newParts;\n    });\n\n    // Remove _matched key.\n    parsedTexts.forEach((parsedText) => delete parsedText._matched);\n\n    return parsedTexts.filter((t) => !!t.children);\n  }\n\n  // private\n\n  /**\n   * @protected\n   * @param {ParseShape} matchedPattern - pattern configuration of the pattern used to match the text\n   * @param {String} text - Text matching the pattern\n   * @param {String[]} matches - Result of the RegExp.exec\n   * @param {Integer} index - Index of the matched string in the whole string\n   * @return {Object} props for the matched text\n   */\n  getMatchedPart(matchedPattern, text, matches, index) {\n    let props = {};\n\n    Object.keys(matchedPattern).forEach((key) => {\n      if (\n        key === 'pattern' ||\n        key === 'renderText' ||\n        key === 'nonExhaustiveModeMaxMatchCount'\n      ) {\n        return;\n      }\n\n      if (typeof matchedPattern[key] === 'function') {\n        // Support onPress / onLongPress functions\n        props[key] = () => matchedPattern[key](text, index);\n      } else {\n        // Set a prop with an arbitrary name to the value in the match-config\n        props[key] = matchedPattern[key];\n      }\n    });\n\n    let children = text;\n    if (\n      matchedPattern.renderText &&\n      typeof matchedPattern.renderText === 'function'\n    ) {\n      children = matchedPattern.renderText(text, matches);\n    }\n\n    return {\n      ...props,\n      children: children,\n      _matched: true,\n    };\n  }\n}\n\nexport default TextExtraction;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}